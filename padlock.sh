#!/usr/bin/env bash
# Generated by build.sh on Sun Aug 17 01:06:27 UTC 2025
# Auto-assembled from numbered modules: 01_header.sh 02_config.sh 03_stderr.sh 04_helpers.sh 05_printers.sh 06_api.sh 07_core.sh 08_main.sh 09_footer.sh
# === 01_header.sh ===
#!/usr/bin/env bash
#
#  ____            _  _            _    
# |  _ \ __ _  __| || | ___   ___| | __
# | |_) / _` |/ _` || |/ _ \ / __| |/ /
# |  __/ (_| | (_| || | (_) | (__|   < 
# |_|   \__,_|\__,_||_|\___/ \___|_|\_\
#                                     
# Git Repository Security Orchestrator
#
# name: padlock
# version: 1.0.0
# author: fx-padlock
# description: Age-based encryption for git repositories with locker pattern
# 
# portable: age, age-keygen, git, tar, find, curl, head, tail, grep, awk, sed
# builtins: printf, read, local, declare, case, if, for, while, source, export

set -euo pipefail
# === 02_config.sh ===
################################################################################
# Configuration & Bootstrap
################################################################################

# XDG+ Environment (use env first, fallback to local)
XDG_ETC_HOME="${XDG_ETC_HOME:-$HOME/.local/etc}"
XDG_LIB_HOME="${XDG_LIB_HOME:-$HOME/.local/lib}"
XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/data}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

# Script identity
readonly SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
readonly SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
readonly SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Padlock configuration
readonly PADLOCK_VERSION="1.0.0"
readonly PADLOCK_ETC="$XDG_ETC_HOME/padlock"
readonly PADLOCK_KEYS="$PADLOCK_ETC/keys"
readonly PADLOCK_GLOBAL_KEY="$PADLOCK_KEYS/global.key"
readonly PADLOCK_CONFIG="$PADLOCK_ETC/config"

# Runtime paths (determined at execution)
REPO_ROOT=""
LOCKER_DIR=""
LOCKER_BLOB=""
LOCKER_CONFIG=""

# Options (set by options() function)
opt_debug=0
opt_trace=0
opt_quiet=0
opt_force=0
opt_yes=0
opt_dev=0

# Bootstrap - ensure critical directories exist
mkdir -p "$PADLOCK_ETC" "$PADLOCK_KEYS"
# === 03_stderr.sh ===
################################################################################
# stderr - BASHFX-Compliant Output Functions
################################################################################

# Color palette
red=$'\x1B[31m'
orange=$'\x1B[38;5;214m'
yellow=$'\x1B[33m'
green=$'\x1B[32m'
blue=$'\x1B[38;5;39m'
cyan=$'\x1B[38;5;14m'
magenta=$'\x1B[35m'
purple=$'\x1B[38;5;213m'
white=$'\x1B[38;5;15m'
grey=$'\x1B[38;5;249m'
grey2=$'\x1B[38;5;240m'
xx=$'\x1B[0m'

# Respect NO_COLOR environment
if [[ -n "${NO_COLOR:-}" ]]; then
    red="" orange="" yellow="" green="" blue="" cyan=""
    magenta="" purple="" white="" grey="" grey2="" xx=""
fi

# Glyphs
fail=$'\u2715'        # ✕
pass=$'\u2713'        # ✓
recv=$'\u27F2'        # ⟲
delta=$'\u25B3'       # △
boto=$'\u232C'        # ⌬
star=$'\xE2\x98\x85'  # ★
lambda=$'\xCE\xBB'    # λ
idots=$'\xE2\x80\xA6' # …
bolt=$'\xE2\x86\xAF'  # ↯
redo=$'\xE2\x86\xBB'  # ↻
spark=$'\u273B'       # ✻
unlock=$'\u26BF'      # ⚿

# Core printer function
__printx() {
    local text="$1" color="$2" prefix="$3" stream="${4:-2}"
    local color_code="${!color:-$white}"
    [[ -n "$text" ]] && printf "%b" "${color_code}${prefix}${text}${xx}" >&"$stream"
}

# Log dispatcher
__log() {
    local type="$1" text="$2" force="${3:-1}" # Public functions pass 0 for force, so default is 1 (don't force)
    
    # In quiet mode, suppress everything except fatal and error, unless forced.
    if [[ "$opt_quiet" -eq 0 && "$force" -ne 0 ]]; then
        case "$type" in
            fatal|error)
                # always show fatal/error
                ;;
            *)
                return 0
                ;;
        esac
    fi
    
    case "$type" in
        fatal) __printx "$text\n" "red" "$fail " 2; exit 1 ;;
        error) __printx "$text\n" "red" "$fail " 2 ;;
        warn)  __printx "$text\n" "orange" "$delta " 2 ;;
        okay)  __printx "$text\n" "green" "$pass " 2 ;;
        lock)  __printx "$text\n" "cyan" "$unlock " 2 ;;

        # info is for debug mode
        info)
            if [[ "$opt_debug" -eq 0 ]]; then
                 __printx "$text\n" "blue" "$recv " 2
            fi
            ;;

        # trace/think is for trace mode
        trace)
            if [[ "$opt_trace" -eq 0 ]]; then
                __printx "$text\n" "grey" "$idots " 2
            fi
            ;;
        think)
            if [[ "$opt_trace" -eq 0 ]]; then
                __printx "$text\n" "purple" "$lambda " 2
            fi
            ;;
    esac
}

# Public interface
fatal() { __log fatal "$1" "${2:-0}"; }
error() { __log error "$1" "${2:-0}"; }
warn()  { __log warn  "$1" "${2:-0}"; }
okay()  { __log okay  "$1" "${2:-0}"; }
info()  { __log info  "$1" "${2:-0}"; }
trace() { __log trace "$1" "${2:-0}"; }
think() { __log think "$1" "${2:-0}"; }
lock()  { __log lock  "$1" "${2:-0}"; }
# === 04_helpers.sh ===
################################################################################
# Helper Functions - Mid and Low-Level
################################################################################

# Guard functions (is_* pattern)
is_git_repo() {
    local target_dir="${1:-.}"
    [[ -d "$target_dir/.git" ]] || [[ -d "$target_dir/.gitsim" ]]
}

is_deployed() {
    local repo_root="$1"
    [[ -f "$repo_root/bin/age-wrapper" ]] && [[ -f "$repo_root/.gitattributes" ]]
}

is_dev() {
    [[ "$opt_dev" -eq 1 ]] || [[ -n "${DEV_MODE:-}" ]]
}

is_locked() {
    local repo_root="$1"
    [[ -f "$repo_root/.locked" ]]
}

is_unlocked() {
    local repo_root="$1"
    [[ -d "$repo_root/locker" ]] && [[ -f "$repo_root/locker/.padlock" ]]
}

# Mid-level helpers
_get_repo_root() {
    local start_dir="${1:-.}"
    local current_dir
    current_dir=$(realpath "$start_dir")

    while [[ "$current_dir" != "/" ]]; do
        if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done

    # Check root ('/') directory as a last resort
    if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
        echo "$current_dir"
        return 0
    fi

    fatal "Not a git or gitsim repository"
}

_get_lock_state() {
    local repo_root="$1"
    if is_locked "$repo_root"; then
        echo "locked"
    elif is_unlocked "$repo_root"; then
        echo "unlocked"
    else
        echo "unknown"
    fi
}

_load_crypto_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        trace "Loaded crypto config from $config_file"
    else
        # Try environment variables as fallback
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            error "No crypto config found"
            info "Run: padlock setup"
            return 1
        fi
        trace "Using crypto config from environment"
    fi
}

_validate_age_installation() {
    if ! command -v age >/dev/null 2>&1; then
        error "age not installed"
        info "Installing age..."
        __install_age || fatal "Failed to install age"
    fi
    trace "age available: $(age --version 2>/dev/null | head -1)"
}

_append_gitattributes() {
    local repo_root="$1"
    local gitattributes="$repo_root/.gitattributes"
    
    if [[ -f "$gitattributes" ]]; then
        if ! grep -q "locker.age filter=locker-crypt" "$gitattributes"; then
            {
                echo ""
                echo "# Padlock encryption"
                echo "locker.age filter=locker-crypt"
                echo "locker.age binary"
                echo ""
                echo "# Keep tools plaintext"
                echo "bin/* -filter"
                echo ".githooks/* -filter"
            } >> "$gitattributes"
            trace "Appended to existing .gitattributes"
        else
            trace ".gitattributes already configured"
        fi
    else
        __print_gitattributes "$gitattributes"
        trace "Created new .gitattributes"
    fi
}

_append_gitignore() {
    local repo_root="$1"
    local gitignore="$repo_root/.gitignore"
    
    if [[ -f "$gitignore" ]]; then
        if ! grep -q "^locker/$" "$gitignore"; then
            {
                echo ""
                echo "# Padlock - never commit plaintext locker"
                echo "locker/"
            } >> "$gitignore"
            trace "Appended to existing .gitignore"
        else
            trace ".gitignore already configured"
        fi
    else
        __print_gitignore "$gitignore"
        trace "Created new .gitignore"
    fi
}

# Low-level literal functions
__install_age() {
    trace "Attempting to install age..."
    
    if command -v apt-get >/dev/null 2>&1; then
        sudo apt-get update -qq && sudo apt-get install -y age
    elif command -v brew >/dev/null 2>&1; then
        brew install age
    elif command -v pacman >/dev/null 2>&1; then
        sudo pacman -S age
    elif command -v nix-env >/dev/null 2>&1; then
        nix-env -iA nixpkgs.age
    elif command -v apk >/dev/null 2>&1; then
        sudo apk add age
    else
        __install_age_binary
    fi
    
    command -v age >/dev/null 2>&1
}

__install_age_binary() {
    local os arch download_url
    
    os="$(uname -s | tr '[:upper:]' '[:lower:]')"
    arch="$(uname -m)"
    
    case "$arch" in
        x86_64) arch="amd64" ;;
        aarch64|arm64) arch="arm64" ;;
        *) fatal "Unsupported architecture: $arch" ;;
    esac
    
    case "$os" in
        linux|darwin) ;;
        *) fatal "Unsupported OS: $os" ;;
    esac
    
    download_url="https://github.com/FiloSottile/age/releases/latest/download/age-v1.1.1-${os}-${arch}.tar.gz"
    trace "Downloading: $download_url"
    
    curl -sL "$download_url" | tar xz --strip-components=1 -C /tmp
    
    if sudo mv /tmp/age /usr/local/bin/ 2>/dev/null && sudo mv /tmp/age-keygen /usr/local/bin/ 2>/dev/null; then
        trace "Installed to /usr/local/bin/"
    else
        mkdir -p "$HOME/.local/bin"
        mv /tmp/age "$HOME/.local/bin/"
        mv /tmp/age-keygen "$HOME/.local/bin/"
        export PATH="$HOME/.local/bin:$PATH"
        trace "Installed to $HOME/.local/bin/"
    fi
}

__encrypt_stream() {
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        IFS=',' read -ra recips <<< "$AGE_RECIPIENTS"
        local age_args=()
        for recip in "${recips[@]}"; do
            age_args+=("-r" "$recip")
        done
        age "${age_args[@]}"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -p
    else
        fatal "No encryption method configured"
    fi
}

__decrypt_stream() {
    if [[ -n "${AGE_KEY_FILE:-}" && -f "$AGE_KEY_FILE" ]]; then
        age -d -i "$AGE_KEY_FILE"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -d -p
    else
        fatal "No decryption key available"
    fi
}
# === 05_printers.sh ===
################################################################################
# File Printers - Low-Level Content Generation
################################################################################

__print_gitattributes() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock encryption" \
        "locker.age filter=locker-crypt" \
        "locker.age binary" \
        "" \
        "# Keep tools plaintext" \
        "bin/* -filter" \
        ".githooks/* -filter"
    
    printf "%s\n" "$content" > "$file"
}

__print_gitignore() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock - never commit plaintext locker" \
        "locker/"
    
    printf "%s\n" "$content" > "$file"
}

__print_age_wrapper() {
    local file="$1"
    local repo_root="$2"
    
    cat > "$file" << 'AGE_WRAPPER_EOF'
#!/usr/bin/env bash
set -euo pipefail

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

MODE="${1:-}"
REPO_ROOT="$(_find_root)"
CRYPTO_CONFIG="$REPO_ROOT/locker/.padlock"
LOCKER_DIR="$REPO_ROOT/locker"
LOCKER_BLOB="$REPO_ROOT/locker.age"

load_config() {
    if [[ -f "$CRYPTO_CONFIG" ]]; then
        source "$CRYPTO_CONFIG"
    else
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            echo "✗ No crypto config. Run: bin/padlock setup" >&2
            exit 1
        fi
    fi
}

encrypt_locker() {
    if [[ ! -d "$LOCKER_DIR" ]]; then
        echo "✗ Locker folder not found: $LOCKER_DIR" >&2
        exit 1
    fi
    
    tar --sort=name --mtime='@0' --owner=0 --group=0 --numeric-owner \
        -C "$REPO_ROOT" -czf - "locker" | encrypt_stream
}

decrypt_locker() {
    [[ -d "$LOCKER_DIR" ]] && rm -rf "$LOCKER_DIR"
    decrypt_stream | tar -C "$REPO_ROOT" -xzf -
}

encrypt_stream() {
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        IFS=',' read -ra RECIPS <<< "$AGE_RECIPIENTS"
        local age_args=()
        for recip in "${RECIPS[@]}"; do
            age_args+=("-r" "$recip")
        done
        age "${age_args[@]}"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -p
    else
        echo "✗ No encryption method configured" >&2
        exit 1
    fi
}

decrypt_stream() {
    if [[ -n "${AGE_KEY_FILE:-}" && -f "$AGE_KEY_FILE" ]]; then
        age -d -i "$AGE_KEY_FILE"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -d -p
    else
        echo "✗ No decryption key available" >&2
        exit 1
    fi
}

case "$MODE" in
    "clean") load_config && encrypt_locker ;;
    "smudge") load_config && decrypt_locker >/dev/null ;;
    *) echo "Usage: age-wrapper {clean|smudge}"; exit 1 ;;
esac
AGE_WRAPPER_EOF
    
    chmod +x "$file"
}

__print_hook() {
    local file="$1"
    local hook_type="$2"
    local repo_root="$3"
    
    # Define the finder function once to be used in all hooks
    local finder_func
    finder_func=$(cat << 'FINDER_EOF'
_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}
REPO_ROOT="$(_find_root)"
FINDER_EOF
)

    case "$hook_type" in
        "pre-commit")
            cat > "$file" << HOOK_EOF
#!/usr/bin/env bash
set -euo pipefail

$finder_func

if [[ -d "\$REPO_ROOT/locker" ]] && [[ -n "\$(find "\$REPO_ROOT/locker" -type f 2>/dev/null)" ]]; then
    echo "🔐 Encrypting locker/ → locker.age"
    if "\$REPO_ROOT/bin/padlock" lock; then
        # This part is tricky because gitsim doesn't have a staging area like git.
        # For real git, this is correct. For gitsim, this command will fail.
        # This is an acceptable limitation for now.
        if [[ -d "\$REPO_ROOT/.git" ]]; then
            git add locker.age
        fi
    else
        echo "✗ Failed to encrypt locker" >&2
        exit 1
    fi
fi
HOOK_EOF
            ;;
        "post-checkout")
            cat > "$file" << HOOK_EOF
#!/usr/bin/env bash
set -euo pipefail

$finder_func

if [[ -f "\$REPO_ROOT/locker.age" ]] && [[ ! -d "\$REPO_ROOT/locker" ]]; then
    echo "🔓 Auto-unlocking locker..."
    if ! "\$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "⚠️  Cannot auto-unlock (missing keys?)"
        echo "    Run: source .locked"
    fi
fi
HOOK_EOF
            ;;
        "post-merge")
            cat > "$file" << HOOK_EOF
#!/usr/bin/env bash
set -euo pipefail

$finder_func

# For real git. This will not work for gitsim. Acceptable limitation.
if [[ -d "\$REPO_ROOT/.git" ]] && git diff --name-only HEAD@{1} HEAD 2>/dev/null | grep -q "^locker.age$"; then
    echo "🔄 Locker updated in merge, refreshing..."
    if ! "\$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "⚠️  Cannot decrypt updated locker (missing keys?)"
    fi
fi
HOOK_EOF
            ;;
    esac
    
    chmod +x "$file"
}

__print_padlock_config() {
    local file="$1"
    local repo_name="$2"
    
    cat > "$file" << EOF
#!/bin/bash
# Padlock configuration for $repo_name
# This file is only present when locker is unlocked

export AGE_RECIPIENTS='${AGE_RECIPIENTS:-}'
export AGE_KEY_FILE='${AGE_KEY_FILE:-}'
export AGE_PASSPHRASE='${AGE_PASSPHRASE:-}'
export PADLOCK_REPO='$REPO_ROOT'

# Project-specific settings
export PROJECT_NAME='$repo_name'
EOF
}

__print_locked_file() {
    local file="$1"
    local checksum="$2"
    
    cat > "$file" << EOF
#!/bin/bash
# Padlock unlock script - source this file to unlock secrets
# Usage: source .locked

if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]; then
    echo "Usage: source .locked (don't execute directly)"
    exit 1
fi

echo "🔓 Unlocking padlock..."

# Set crypto environment from stored config
export AGE_RECIPIENTS='${AGE_RECIPIENTS:-}'
export AGE_KEY_FILE='${AGE_KEY_FILE:-}'  
export AGE_PASSPHRASE='${AGE_PASSPHRASE:-}'
export PADLOCK_CHECKSUM='${checksum:-}'

# Unlock the locker
if bin/padlock unlock; then
    echo "✓ Locker unlocked"
    if [[ -f "locker/.padlock" ]]; then
        source locker/.padlock
        export PADLOCK_UNLOCKED=1
        echo "✓ Environment loaded from .padlock"
    fi
else
    echo "✗ Failed to unlock locker"
fi
EOF
}

__print_security_md() {
    local file="$1"
    
    cat > "$file" << 'SECURITY_EOF'
# Repository Security with Padlock

This repository uses **Padlock** for encrypting sensitive files using the `age` encryption tool.

## How It Works

- **Locker Directory**: Sensitive files go in `locker/` (plaintext locally, never committed)
- **Encrypted Storage**: Git stores `locker.age` (encrypted binary blob)
- **State Files**: 
  - `.locked` exists when secrets are encrypted (run `source .locked` to unlock)
  - `locker/.padlock` exists when secrets are accessible (contains crypto config)

## Quick Start

```bash
# Setup encryption (first time)
bin/padlock setup

# Unlock secrets (when .locked file exists)
source .locked

# Lock secrets manually
bin/padlock lock

# Check status
bin/padlock status
```

## Directory Structure

```
locker/
├── docs_sec/           # Secure documentation
├── conf_sec/           # Configuration files, API keys
└── .padlock           # Crypto configuration (unlocked state)
```

## Commands

- `bin/padlock status` - Check lock/unlock state
- `bin/padlock lock` - Encrypt locker/ → locker.age
- `bin/padlock unlock` - Decrypt locker.age → locker/
- `bin/padlock setup` - Initial encryption setup
- `source .locked` - Unlock and source crypto config

## Team Sharing

```bash
# Add team member's public key
bin/padlock key --add-recipient age1abc123...

# Generate your public key to share
bin/padlock key --show-global
```

## Notes

- Files in `locker/` are automatically encrypted on commit
- `locker.age` is automatically decrypted on checkout
- Remove this file once you're familiar with the system
- Never commit the `locker/` directory - it's in `.gitignore`

Created by Padlock v1.0.0
SECURITY_EOF
}

__print_starter_files() {
    local locker_dir="$1"
    
    mkdir -p "$locker_dir/docs_sec" "$locker_dir/conf_sec"
    
    cat > "$locker_dir/docs_sec/AGENT.md" << 'AGENT_EOF'
# AI Agent Instructions

This file contains instructions for AI agents working on this project.

## System Prompt

You are an AI assistant working on this project. This content is encrypted 
and only visible when the repository locker is unlocked.

## Guidelines

- Follow project conventions
- Be helpful and concise
- Ask for clarification when needed

## Context

This file is part of the secure locker and will be encrypted in git.
Add your AI-specific instructions and context here.
AGENT_EOF
    
    cat > "$locker_dir/conf_sec/project.conf" << 'CONF_EOF'
# Project Configuration
# Secure configuration file - encrypted in git

# API Keys (example)
# API_KEY=your-secret-key
# DATABASE_URL=postgresql://user:pass@host/db

# Environment specific settings
ENV=development

# Add your secure configuration here
CONF_EOF
}
# === 06_api.sh ===
################################################################################
# API Functions - High-Level Dispatchable (do_* pattern)
################################################################################

do_clamp() {
    local target_path="${1:-.}"
    local use_global_key=false
    local generate_key=false
    local explicit_key=""
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global-key) use_global_key=true; shift ;;
            --generate) generate_key=true; shift ;;
            --key) explicit_key="$2"; shift 2 ;;
            *) error "Unknown option: $1"; return 1 ;;
        esac
    done
    
    target_path="$(realpath "$target_path")"
    info "Deploying padlock to: $target_path"
    
    # Validate target
    if ! is_git_repo "$target_path"; then
        fatal "Target is not a git repository: $target_path"
    fi
    
    REPO_ROOT="$(_get_repo_root "$target_path")"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    # Check if already deployed
    if is_deployed "$REPO_ROOT"; then
        warn "Padlock already deployed to this repository"
        info "Use 'padlock update' to refresh files"
        return 0
    fi
    
    lock "🔧 Setting up padlock structure..."
    
    # Ensure age is available
    _validate_age_installation
    
    # Create bin directory and copy tools
    mkdir -p "$REPO_ROOT/bin"
    
    # Copy self to target repo
    cp "$SCRIPT_PATH" "$REPO_ROOT/bin/padlock"
    chmod +x "$REPO_ROOT/bin/padlock"
    trace "Copied padlock to bin/"
    
    # Create age-wrapper
    __print_age_wrapper "$REPO_ROOT/bin/age-wrapper" "$REPO_ROOT"
    trace "Created age-wrapper"
    
    # Create .githooks directory and hooks
    mkdir -p "$REPO_ROOT/.githooks"
    __print_hook "$REPO_ROOT/.githooks/pre-commit" "pre-commit" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-checkout" "post-checkout" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-merge" "post-merge" "$REPO_ROOT"
    trace "Created git hooks"
    
    # Update git configuration files
    _append_gitattributes "$REPO_ROOT"
    _append_gitignore "$REPO_ROOT"
    
    # Configure git
    git -C "$REPO_ROOT" config filter.locker-crypt.clean "$REPO_ROOT/bin/age-wrapper clean"
    git -C "$REPO_ROOT" config filter.locker-crypt.smudge "$REPO_ROOT/bin/age-wrapper smudge"
    git -C "$REPO_ROOT" config filter.locker-crypt.required true
    git -C "$REPO_ROOT" config core.hooksPath .githooks
    trace "Configured git filters and hooks"
    
    # Handle key setup
    if [[ -n "$explicit_key" ]]; then
        AGE_RECIPIENTS="$explicit_key"
        info "Using explicit key: $explicit_key"
    elif [[ "$use_global_key" == true ]]; then
        if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
            AGE_RECIPIENTS="$(cat "$PADLOCK_GLOBAL_KEY")"
            info "Using global key"
        else
            warn "No global key found, generating new one"
            generate_key=true
        fi
    elif [[ "$generate_key" == true ]]; then
        info "Generating new keypair for repository"
    else
        # Default behavior - try global key, fallback to generate
        if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
            AGE_RECIPIENTS="$(cat "$PADLOCK_GLOBAL_KEY")"
            info "Using existing global key"
        else
            generate_key=true
        fi
    fi
    
    # Generate keypair if needed
    if [[ "$generate_key" == true ]]; then
        local key_file="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        age-keygen -o "$key_file"
        
        AGE_RECIPIENTS=$(grep "public key:" "$key_file" | awk '{print $4}')
        AGE_KEY_FILE="$key_file"
        
        okay "Generated keypair: $key_file"
        info "Public key: $AGE_RECIPIENTS"
        
        # Store as global if requested
        if [[ "$use_global_key" == true ]]; then
            echo "$AGE_RECIPIENTS" > "$PADLOCK_GLOBAL_KEY"
            okay "Saved as global key"
        fi
    fi
    
    # Create locker structure and starter files
    mkdir -p "$LOCKER_DIR"
    __print_starter_files "$LOCKER_DIR"
    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"
    
    # Create SECURITY.md
    __print_security_md "$REPO_ROOT/SECURITY.md"
    
    # Update manifest
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    touch "$manifest_file"
    if ! grep -q -F -x "$REPO_ROOT" "$manifest_file"; then
        echo "$REPO_ROOT" >> "$manifest_file"
        trace "Added $REPO_ROOT to manifest"
    fi

    okay "Padlock deployment complete!"
    info "Add sensitive files to locker/ directory"
    info "Run 'bin/padlock status' to check state"
}

do_setup() {
    REPO_ROOT="$(_get_repo_root)"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    if [[ ! -f "$REPO_ROOT/bin/age-wrapper" ]]; then
        fatal "Padlock not deployed. Run 'padlock clamp' first"
    fi
    
    lock "🔧 Setting up padlock encryption..."
    
    _validate_age_installation
    
    # Use existing config if available
    if [[ -f "$LOCKER_CONFIG" ]]; then
        _load_crypto_config "$LOCKER_CONFIG"
        okay "Using existing configuration"
        return 0
    fi
    
    # Generate keypair if no crypto provided
    if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
        info "Generating new encryption keypair..."
        local key_file="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        mkdir -p "$(dirname "$key_file")"
        age-keygen -o "$key_file"
        
        AGE_RECIPIENTS=$(grep "public key:" "$key_file" | awk '{print $4}')
        AGE_KEY_FILE="$key_file"
        
        okay "Generated keypair: $key_file"
        info "Public key: $AGE_RECIPIENTS"
    fi
    
    # Create locker structure if needed
    if [[ ! -d "$LOCKER_DIR" ]]; then
        mkdir -p "$LOCKER_DIR"
        __print_starter_files "$LOCKER_DIR"
    fi
    
    # Create .padlock config
    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"
    
    okay "Padlock encryption configured!"
    info "Edit files in locker/ then commit normally"
}

do_lock() {
    REPO_ROOT="$(_get_repo_root)"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    if [[ ! -d "$LOCKER_DIR" ]]; then
        error "No locker directory found"
        return 1
    fi
    
    if [[ ! -f "$LOCKER_CONFIG" ]]; then
        error "No .padlock config found. Run 'padlock setup' first"
        return 1
    fi
    
    lock "🔐 Locking locker..."
    
    # Load crypto config
    _load_crypto_config "$LOCKER_CONFIG"
    
    # Calculate checksum of locker contents
    local checksum
    checksum=$(cd "$LOCKER_DIR" && find . -type f -print0 | sort -z | xargs -0 md5sum | md5sum | awk '{print $1}')
    trace "Calculated locker checksum: $checksum"

    # Encrypt locker to locker.age
    tar --sort=name --mtime='@0' --owner=0 --group=0 --numeric-owner \
        -C "$REPO_ROOT" -czf - "locker" | __encrypt_stream > "$LOCKER_BLOB"
    
    # Create .locked file with unlock instructions
    __print_locked_file "$REPO_ROOT/.locked" "$checksum"
    
    # Remove plaintext locker
    rm -rf "$LOCKER_DIR"
    
    local size
    size=$(du -h "$LOCKER_BLOB" | cut -f1)
    okay "Locker locked → locker.age ($size)"
    info "Created .locked file for unlocking"
    info "Run 'source .locked' to unlock"
}

do_unlock() {
    REPO_ROOT="$(_get_repo_root)"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    if [[ ! -f "$LOCKER_BLOB" ]]; then
        error "No locker.age found"
        return 1
    fi
    
    lock "🔓 Unlocking locker..."
    
    # Decrypt locker.age to locker/
    __decrypt_stream < "$LOCKER_BLOB" | tar -C "$REPO_ROOT" -xzf -
    
    if [[ -d "$LOCKER_DIR" ]] && [[ -f "$LOCKER_CONFIG" ]]; then
        # Verify checksum if it exists
        if [[ -n "${PADLOCK_CHECKSUM:-}" ]]; then
            trace "Verifying checksum..."
            local new_checksum
            new_checksum=$(cd "$LOCKER_DIR" && find . -type f -print0 | sort -z | xargs -0 md5sum | md5sum | awk '{print $1}')
            if [[ "$new_checksum" != "$PADLOCK_CHECKSUM" ]]; then
                error "Checksum mismatch! The locker archive may be corrupt."
                info "Expected: $PADLOCK_CHECKSUM"
                info "Got:      $new_checksum"
                # Clean up potentially corrupt directory
                rm -rf "$LOCKER_DIR"
                fatal "Aborting to prevent data loss."
            fi
            trace "Checksum OK: $new_checksum"
        fi

        # Remove .locked file and locker.age since we're now unlocked
        rm -f "$REPO_ROOT/.locked"
        rm -f "$LOCKER_BLOB"
        
        local file_count
        file_count=$(find "$LOCKER_DIR" -type f 2>/dev/null | wc -l)
        okay "Locker unlocked ($file_count files)"
        info "Removed .locked and locker.age"
    else
        error "Failed to unlock locker"
        return 1
    fi
}

do_status() {
    REPO_ROOT="$(_get_repo_root)"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    
    printf "%s=== Padlock Status ===%s\n" "$blue" "$xx"
    printf "Repository: %s\n" "$(basename "$REPO_ROOT")"
    printf "Deployed: %s\n" "$(is_deployed "$REPO_ROOT" && echo "✓ Yes" || echo "✗ No")"
    
    local state
    state="$(_get_lock_state "$REPO_ROOT")"
    case "$state" in
        "locked")
            printf "State: %s🔒 LOCKED%s\n" "$red" "$xx"
            printf "Unlock: %ssource .locked%s\n" "$cyan" "$xx"
            ;;
        "unlocked") 
            printf "State: %s🔓 UNLOCKED%s\n" "$green" "$xx"
            if [[ -d "$LOCKER_DIR" ]]; then
                local file_count dir_count
                file_count=$(find "$LOCKER_DIR" -type f 2>/dev/null | wc -l)
                dir_count=$(find "$LOCKER_DIR" -type d 2>/dev/null | tail -n +2 | wc -l)
                printf "Locker: %d files in %d directories\n" "$file_count" "$dir_count"
            fi
            ;;
        *)
            printf "State: %s❓ UNKNOWN%s\n" "$yellow" "$xx"
            printf "Run: %spadlock setup%s\n" "$cyan" "$xx"
            ;;
    esac
    
    if [[ -f "$LOCKER_BLOB" ]]; then
        local size
        size=$(du -h "$LOCKER_BLOB" | cut -f1)
        printf "Encrypted: locker.age (%s)\n" "$size"
    fi
}

do_key() {
    local action="$1"
    shift
    
    case "$action" in
        --set-global)
            local key="$1"
            if [[ -z "$key" ]]; then
                fatal "Key required for --set-global"
            fi
            mkdir -p "$PADLOCK_KEYS"
            echo "$key" > "$PADLOCK_GLOBAL_KEY"
            okay "Global key saved"
            ;;
        --show-global)
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                cat "$PADLOCK_GLOBAL_KEY"
            else
                error "No global key found"
                return 1
            fi
            ;;
        --generate-global)
            mkdir -p "$PADLOCK_KEYS"
            local temp_key="/tmp/padlock-global-$.key"
            age-keygen -o "$temp_key"
            
            local public_key
            public_key=$(grep "public key:" "$temp_key" | awk '{print $4}')
            echo "$public_key" > "$PADLOCK_GLOBAL_KEY"
            
            mv "$temp_key" "$PADLOCK_KEYS/global.key"
            okay "Generated global key: $public_key"
            ;;
        *)
            error "Unknown key action: $action"
            info "Available: --set-global, --show-global, --generate-global"
            return 1
            ;;
    esac
}

do_install() {
    lock "Installing padlock for global use..."

    local install_dir="$XDG_LIB_HOME/fx/padlock"
    local bin_dir="$XDG_BIN_HOME/fx"
    local link_path="$bin_dir/padlock"

    mkdir -p "$install_dir"
    mkdir -p "$bin_dir"

    cp "$SCRIPT_PATH" "$install_dir/padlock.sh"
    chmod +x "$install_dir/padlock.sh"
    trace "Copied script to $install_dir"

    ln -sf "$install_dir/padlock.sh" "$link_path"
    trace "Created symlink at $link_path"

    okay "Padlock installed successfully!"

    # Check if the install directory is in the user's PATH
    if ! [[ ":$PATH:" == *":$bin_dir:"* ]]; then
        warn "The directory '$bin_dir' is not in your PATH."
        info "Please add it to your shell's startup file (e.g., .bashrc, .zshrc):"
        info "  export PATH=\"\$PATH:$bin_dir\""
    fi
}

do_uninstall() {
    local purge_all=false
    if [[ "${1:-}" == "--purge-all-data" ]]; then
        purge_all=true
    fi

    lock "Uninstalling padlock..."

    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" && -s "$manifest_file" ]]; then
        if [[ "$purge_all" == true && "$opt_dev" -eq 1 ]]; then
            warn "Purging all padlock data, including manifest and keys..."
            rm -rf "$PADLOCK_ETC"
            okay "All padlock data has been purged."
        else
            error "Padlock is still managing the following repositories:"
            cat "$manifest_file"
            info "Please manually remove padlock from these repositories before uninstalling."
            info "To override this safety check and purge all keys and data, run with -D and --purge-all-data."
            return 1
        fi
    fi

    local install_dir="$XDG_LIB_HOME/fx/padlock"
    local link_path="$XDG_BIN_HOME/fx/padlock"

    if [[ -L "$link_path" ]]; then
        rm "$link_path"
        okay "Removed symlink: $link_path"
    fi

    if [[ -d "$install_dir" ]]; then
        rm -rf "$install_dir"
        okay "Removed installation directory: $install_dir"
    fi

    if [[ "$purge_all" == false ]]; then
        info "Keys and manifest file have been preserved in $PADLOCK_ETC"
    fi

    okay "Padlock uninstalled successfully."
}
# === 07_core.sh ===
################################################################################
# Core Interface - Dispatch, Usage, Options
################################################################################

dispatch() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        clamp)
            do_clamp "$@"
            ;;
        setup)
            do_setup "$@"
            ;;
        lock)
            do_lock "$@"
            ;;
        unlock)
            do_unlock "$@"
            ;;
        status)
            do_status "$@"
            ;;
        key)
            do_key "$@"
            ;;
        install)
            do_install "$@"
            ;;
        uninstall)
            do_uninstall "$@"
            ;;
        help|--help|-h)
            usage
            ;;
        version|--version|-v)
            printf "padlock %s\n" "$PADLOCK_VERSION"
            ;;
        dev_test)
            if is_dev; then
                dev_test "$@"
            else
                fatal "Dev command requires -D flag"
            fi
            ;;
        *)
            error "Unknown command: $cmd"
            info "Run 'padlock help' for available commands"
            return 1
            ;;
    esac
}

usage() {
    cat << 'USAGE_EOF'
Padlock - Git Repository Security Orchestrator

USAGE:
    padlock <command> [options]

COMMANDS:
    clamp <path>     Deploy padlock to a git repository
      --global-key   Use or create global key
      --generate     Generate new repo-specific key
      --key <key>    Use explicit key

    setup           Setup encryption (first time in repo)
    lock            Encrypt locker/ → locker.age
    unlock          Decrypt locker.age → locker/
    status          Show current lock/unlock state

    key             Manage encryption keys
      --set-global <key>      Store global key
      --show-global           Display global key
      --generate-global       Create new global key

    install         Install padlock to your system for global access
    uninstall       Remove padlock from your system

    help            Show this help
    version         Show version

WORKFLOW:
    # Deploy to repository
    padlock clamp /path/to/repo --global-key

    # Work with secrets locally
    cd /path/to/repo
    echo "secret content" > locker/docs_sec/private.md

    # Commit (auto-encrypts)
    git add . && git commit -m "Add secrets"

    # Unlock after checkout
    source .locked

FLAGS:
    -d              Enable debug output
    -t              Enable trace output (implies -d)
    -q              Quiet mode (errors only)
    -f              Force operations
    -y              Auto-answer yes to prompts
    -D              Developer mode (enables dev commands)

EXAMPLES:
    # Deploy with global key
    padlock clamp /my/repo --global-key

    # Deploy with new key for this repo
    padlock clamp /my/repo --generate

    # Check status
    padlock status

    # Manual lock/unlock
    padlock lock
    source .locked

    # Key management
    padlock key --generate-global
    padlock key --show-global

FILES:
    locker/         Plaintext secrets (unlocked state)
    locker.age      Encrypted blob (in git)
    .locked         Unlock script (locked state)
    locker/.padlock Configuration (unlocked state)

SECURITY:
    - locker/ files are encrypted using age (modern encryption)
    - Only filenames are visible, content is completely opaque
    - Supports both public-key and symmetric encryption
    - Keys are never committed to git
    - Team sharing via public key distribution

For more information, see SECURITY.md after deployment.

Version: 1.0.0
USAGE_EOF
}

options() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug)
                opt_debug=1
                trace "Debug mode enabled"
                shift
                ;;
            -t|--trace)
                opt_trace=1
                opt_debug=1  # Trace implies debug
                trace "Trace mode enabled"
                shift
                ;;
            -q|--quiet)
                opt_quiet=1
                shift
                ;;
            -f|--force)
                opt_force=1
                trace "Force mode enabled"
                shift
                ;;
            -y|--yes)
                opt_yes=1
                trace "Auto-yes mode enabled"
                shift
                ;;
            -D|--dev)
                opt_dev=1
                opt_debug=1
                opt_trace=1
                trace "Developer mode enabled"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                printf "padlock %s\n" "$PADLOCK_VERSION"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                error "Unknown option: $1"
                info "Use -h for help"
                exit 1
                ;;
            *)
                # Not an option, break to handle as command
                break
                ;;
        esac
    done
    
    # Return remaining arguments
    return 0
}

################################################################################
# Dev Functions (require -D flag)
################################################################################

dev_test() {
    if ! is_dev; then
        fatal "dev_test requires developer mode (-D)"
    fi
    
    lock "🧪 Running developer tests..."
    
    # Test crypto functions
    info "Testing crypto stream functions..."
    local test_data="test encryption data"
    
    # Set up test crypto
    AGE_PASSPHRASE="test-passphrase-123"
    
    # Test encrypt/decrypt cycle
    local encrypted decrypted
    encrypted=$(echo "$test_data" | __encrypt_stream)
    decrypted=$(echo "$encrypted" | __decrypt_stream)
    
    if [[ "$decrypted" == "$test_data" ]]; then
        okay "Crypto stream test passed"
    else
        error "Crypto stream test failed"
        trace "Expected: $test_data"
        trace "Got: $decrypted"
    fi
    
    # Test guard functions
    info "Testing guard functions..."
    
    if is_dev; then
        okay "is_dev() test passed"
    else
        error "is_dev() test failed"
    fi
    
    # Test repo detection
    info "Testing repo detection..."
    
    if is_git_repo "."; then
        okay "Git repo detection passed"
    else
        warn "Not in a git repo (expected for isolated testing)"
    fi
    
    # Test XDG paths
    info "Testing XDG paths..."
    trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    trace "PADLOCK_ETC: $PADLOCK_ETC"
    trace "PADLOCK_KEYS: $PADLOCK_KEYS"
    
    okay "Developer tests completed"
}
# === 08_main.sh ===
################################################################################
# Main Function - Primary Entrypoint
################################################################################

main() {
    local ret=0
    
    # Early environment checks
    if [[ "${BASH_VERSION%%.*}" -lt 4 ]]; then
        fatal "Bash 4.0+ required (found: $BASH_VERSION)"
    fi
    
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        usage
        return 0
    fi
    
    # Parse options first (modifies opt_* variables)
    options "$@"
    
    # Skip processed options to get to command
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug|-t|--trace|-q|--quiet|-f|--force|-y|--yes|-D|--dev)
                shift
                ;;
            -h|--help|-v|--version)
                # These are handled in options() and exit
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                shift  # Skip unknown options (already handled in options())
                ;;
            *)
                # Found command
                break
                ;;
        esac
    done
    
    # Show startup info in dev mode
    if is_dev; then
        trace "Padlock v$PADLOCK_VERSION starting..."
        trace "Script: $SCRIPT_PATH"
        trace "PID: $$"
        trace "Args: $*"
        trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    fi
    
    # Dispatch to command handlers
    if [[ $# -gt 0 ]]; then
        dispatch "$@" || ret=$?
    else
        # No command provided after parsing options
        usage
    fi
    
    # Clean exit
    if is_dev; then
        trace "Padlock exiting with status: $ret"
    fi
    
    return $ret
}
# === 09_footer.sh ===
################################################################################
# Footer - Script Invocation
################################################################################

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
