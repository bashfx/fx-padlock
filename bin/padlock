#!/usr/bin/env bash
# Generated by build.sh on Mon Aug 25 04:09:22 PM UTC 2025
# Auto-assembled from numbered modules: 01_header.sh 02_config.sh 03_stderr.sh 04_helpers.sh 05_printers.sh 06_api.sh 07_core.sh 08_main.sh 09_footer.sh
# === 01_header.sh ===
#!/usr/bin/env bash
#
#  ____            _  _            _    
# |  _ \ __ _  __| || | ___   ___| | __
# | |_) / _` |/ _` || |/ _ \ / __| |/ /
# |  __/ (_| | (_| || | (_) | (__|   < 
# |_|   \__,_|\__,_||_|\___/ \___|_|\_\
#                                     
# Git Repository Security Orchestrator
#
# name: padlock
# version: 1.0.0
# author: fx-padlock
# description: Age-based encryption for git repositories with locker pattern
# 
# portable: age, age-keygen, git, tar, find, curl, head, tail, grep, awk, sed
# builtins: printf, read, local, declare, case, if, for, while, source, export

set -euo pipefail
# === 02_config.sh ===
################################################################################
# Configuration & Bootstrap
################################################################################

# XDG+ Environment (use env first, fallback to local)
XDG_ETC_HOME="${XDG_ETC_HOME:-$HOME/.local/etc}"
XDG_LIB_HOME="${XDG_LIB_HOME:-$HOME/.local/lib}"
XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/data}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

# Script identity
readonly SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
readonly SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
readonly SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Padlock configuration
readonly PADLOCK_VERSION="1.0.0"
readonly PADLOCK_ETC="$XDG_ETC_HOME/padlock"
readonly PADLOCK_KEYS="$PADLOCK_ETC/keys"
readonly PADLOCK_GLOBAL_KEY="$PADLOCK_KEYS/global.key"
readonly PADLOCK_CONFIG="$PADLOCK_ETC/config"

# Runtime paths (determined at execution)
REPO_ROOT=""
LOCKER_DIR=""
LOCKER_BLOB=""
LOCKER_CONFIG=""

# Options (set by options() function)
opt_debug=0
opt_trace=0
opt_quiet=0
opt_force=0
opt_yes=0
opt_dev=0

# Bootstrap - ensure critical directories exist
mkdir -p "$PADLOCK_ETC" "$PADLOCK_KEYS"
# === 03_stderr.sh ===
################################################################################
# stderr - BASHFX-Compliant Output Functions
################################################################################

# Color palette
red=$'\x1B[31m'
orange=$'\x1B[38;5;214m'
yellow=$'\x1B[33m'
green=$'\x1B[32m'
blue=$'\x1B[38;5;39m'
cyan=$'\x1B[38;5;14m'
magenta=$'\x1B[35m'
purple=$'\x1B[38;5;213m'
white=$'\x1B[38;5;15m'
grey=$'\x1B[38;5;249m'
grey2=$'\x1B[38;5;240m'
xx=$'\x1B[0m'

# Respect NO_COLOR environment
if [[ -n "${NO_COLOR:-}" ]]; then
    red="" orange="" yellow="" green="" blue="" cyan=""
    magenta="" purple="" white="" grey="" grey2="" xx=""
fi

# Glyphs
fail=$'\u2715'        # ‚úï
pass=$'\u2713'        # ‚úì
recv=$'\u27F2'        # ‚ü≤
delta=$'\u25B3'       # ‚ñ≥
boto=$'\u232C'        # ‚å¨
star=$'\xE2\x98\x85'  # ‚òÖ
lambda=$'\xCE\xBB'    # Œª
idots=$'\xE2\x80\xA6' # ‚Ä¶
bolt=$'\xE2\x86\xAF'  # ‚ÜØ
redo=$'\xE2\x86\xBB'  # ‚Üª
spark=$'\u273B'       # ‚úª
unlock=$'\u26BF'      # ‚öø

# Core printer function
__printx() {
    local text="$1" color="$2" prefix="$3" stream="${4:-2}"
    local color_code="${!color:-$white}"
    [[ -n "$text" ]] && printf "%b" "${color_code}${prefix}${text}${xx}" >&"$stream"
}

# Log dispatcher
__log() {
    local type="$1" text="$2" force="${3:-0}" stream=2

    # Respect global quiet mode
    if [[ "$opt_quiet" -eq 0 && "$force" -eq 1 ]]; then
        [[ "$type" == "fatal" || "$type" == "error" ]] || return 0
    fi

    case "$type" in
        fatal) __printx "$text\n" "red" "$fail " "$stream"; exit 1 ;;
        error) __printx "$text\n" "red" "$fail " "$stream" ;;
        warn)  [[ $force -eq 0 || $opt_debug -eq 0 ]] && __printx "$text\n" "orange" "$delta " "$stream" ;;
        okay)  [[ $force -eq 0 || $opt_debug -eq 0 ]] && __printx "$text\n" "green" "$pass " "$stream" ;;
        info)  [[ $opt_debug -eq 0 ]] && __printx "$text\n" "blue" "$recv " "$stream" ;;
        trace) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "grey" "$idots " "$stream" ;;
        think) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "purple" "$lambda " "$stream" ;;
        lock)  __printx "$text\n" "cyan" "$unlock " "$stream" ;;
    esac
}

# Public interface
fatal() { __log fatal "$1" "${2:-0}"; }
error() { __log error "$1" "${2:-0}"; }
warn()  { __log warn  "$1" "${2:-0}"; }
okay()  { __log okay  "$1" "${2:-0}"; }
info()  { __log info  "$1" "${2:-0}"; }
trace() { __log trace "$1" "${2:-0}"; }
think() { __log think "$1" "${2:-0}"; }
lock()  { __log lock  "$1" "${2:-0}"; }
# === 04_helpers.sh ===
################################################################################
# Helper Functions - Mid and Low-Level
################################################################################

# Guard functions (is_* pattern)
is_git_repo() {
    local target_dir="${1:-.}"
    [[ -d "$target_dir/.git" ]] || [[ -d "$target_dir/.gitsim" ]]
}

is_deployed() {
    local repo_root="$1"
    [[ -f "$repo_root/bin/age-wrapper" ]] && [[ -f "$repo_root/.gitattributes" ]]
}

is_dev() {
    [[ "$opt_dev" -eq 1 ]] || [[ -n "${DEV_MODE:-}" ]]
}

is_locked() {
    local repo_root="$1"
    [[ -f "$repo_root/.locked" ]]
}

is_unlocked() {
    local repo_root="$1"
    [[ -d "$repo_root/locker" ]] && [[ -f "$repo_root/locker/.padlock" ]]
}

# Mid-level helpers
_get_repo_root() {
    local start_dir="${1:-.}"
    local current_dir
    current_dir=$(realpath "$start_dir")

    while [[ "$current_dir" != "/" ]]; do
        if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done

    # Check root ('/') directory as a last resort
    if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
        echo "$current_dir"
        return 0
    fi

    fatal "Not a git or gitsim repository"
}

_get_lock_state() {
    local repo_root="$1"
    # Prioritize chest state if it exists, as it's the more modern format.
    if [[ -d "$repo_root/.chest" ]]; then
        echo "locked"
    elif is_locked "$repo_root"; then # Standard lock file
        echo "locked"
    elif is_unlocked "$repo_root"; then
        echo "unlocked"
    else
        echo "unknown"
    fi
}

_load_crypto_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        trace "Loaded crypto config from $config_file"
    else
        # Try environment variables as fallback
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            error "No crypto config found"
            info "Run: padlock setup"
            return 1
        fi
        trace "Using crypto config from environment"
    fi
}

_validate_age_installation() {
    if ! command -v age >/dev/null 2>&1; then
        error "age not installed"
        info "Installing age..."
        __install_age || fatal "Failed to install age"
    fi
    trace "age available: $(age --version 2>/dev/null | head -1)"
}

_append_gitattributes() {
    local repo_root="$1"
    local gitattributes="$repo_root/.gitattributes"
    
    if [[ -f "$gitattributes" ]]; then
        if ! grep -q "locker.age filter=locker-crypt" "$gitattributes"; then
            {
                echo ""
                echo "# Padlock encryption"
                echo "locker.age filter=locker-crypt"
                echo "locker.age binary"
                echo ""
                echo "# Keep tools plaintext"
                echo "bin/* -filter"
                echo ".githooks/* -filter"
            } >> "$gitattributes"
            trace "Appended to existing .gitattributes"
        else
            trace ".gitattributes already configured"
        fi
    else
        __print_gitattributes "$gitattributes"
        trace "Created new .gitattributes"
    fi
}

_append_gitignore() {
    local repo_root="$1"
    local gitignore="$repo_root/.gitignore"
    
    if [[ -f "$gitignore" ]]; then
        if ! grep -q "^locker/$" "$gitignore"; then
            {
                echo ""
                echo "# Padlock - never commit plaintext locker"
                echo "locker/"
            } >> "$gitignore"
            trace "Appended to existing .gitignore"
        else
            trace ".gitignore already configured"
        fi
    else
        __print_gitignore "$gitignore"
        trace "Created new .gitignore"
    fi
}

# Low-level literal functions
__install_age() {
    trace "Attempting to install age..."
    
    if command -v apt-get >/dev/null 2>&1; then
        sudo apt-get update -qq && sudo apt-get install -y age
    elif command -v brew >/dev/null 2>&1; then
        brew install age
    elif command -v pacman >/dev/null 2>&1; then
        sudo pacman -S age
    elif command -v nix-env >/dev/null 2>&1; then
        nix-env -iA nixpkgs.age
    elif command -v apk >/dev/null 2>&1; then
        sudo apk add age
    else
        __install_age_binary
    fi
    
    command -v age >/dev/null 2>&1
}

__install_age_binary() {
    local os arch download_url secure_temp
    
    os="$(uname -s | tr '[:upper:]' '[:lower:]')"
    arch="$(uname -m)"
    
    case "$arch" in
        x86_64) arch="amd64" ;;
        aarch64|arm64) arch="arm64" ;;
        *) fatal "Unsupported architecture: $arch" ;;
    esac
    
    case "$os" in
        linux|darwin) ;;
        *) fatal "Unsupported OS: $os" ;;
    esac
    
    # Use latest stable version with checksum verification
    local version="v1.2.1"  # Latest stable version (security fix)
    download_url="https://github.com/FiloSottile/age/releases/download/${version}/age-${version}-${os}-${arch}.tar.gz"
    local checksum_url="https://github.com/FiloSottile/age/releases/download/${version}/age-${version}-checksums.txt"
    
    trace "Downloading: $download_url"
    trace "Checksums: $checksum_url"
    
    # Create secure temporary directory
    secure_temp=$(mktemp -d)
    trap "rm -rf '$secure_temp'" EXIT
    
    # Download binary and checksums
    if ! curl -sL "$download_url" -o "$secure_temp/age.tar.gz"; then
        fatal "Failed to download age binary"
    fi
    
    if ! curl -sL "$checksum_url" -o "$secure_temp/checksums.txt"; then
        warn "Failed to download checksums - proceeding without verification"
        warn "‚ö†Ô∏è  This reduces security - consider manual verification"
    else
        # Verify checksum
        local expected_file="age-${version}-${os}-${arch}.tar.gz"
        local expected_checksum
        expected_checksum=$(grep "$expected_file" "$secure_temp/checksums.txt" | awk '{print $1}')
        
        if [[ -n "$expected_checksum" ]]; then
            local actual_checksum
            actual_checksum=$(sha256sum "$secure_temp/age.tar.gz" | awk '{print $1}')
            
            if [[ "$expected_checksum" == "$actual_checksum" ]]; then
                okay "‚úì Checksum verification passed"
                trace "Expected: $expected_checksum"
                trace "Actual:   $actual_checksum"
            else
                error "üîí Checksum verification FAILED"
                error "Expected: $expected_checksum"
                error "Actual:   $actual_checksum"
                fatal "Binary integrity compromised - aborting installation"
            fi
        else
            warn "Could not find checksum for $expected_file in checksums.txt"
            warn "‚ö†Ô∏è  Proceeding without checksum verification"
        fi
    fi
    
    # Extract verified binary
    tar xz --strip-components=1 -C "$secure_temp" -f "$secure_temp/age.tar.gz"
    
    if sudo mv "$secure_temp/age" /usr/local/bin/ 2>/dev/null && sudo mv "$secure_temp/age-keygen" /usr/local/bin/ 2>/dev/null; then
        trace "Installed to /usr/local/bin/"
    else
        mkdir -p "$HOME/.local/bin"
        mv "$secure_temp/age" "$HOME/.local/bin/"
        mv "$secure_temp/age-keygen" "$HOME/.local/bin/"
        export PATH="$HOME/.local/bin:$PATH"
        trace "Installed to $HOME/.local/bin/"
    fi
}

__encrypt_stream() {
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        IFS=',' read -ra recips <<< "$AGE_RECIPIENTS"
        local age_args=()
        for recip in "${recips[@]}"; do
            age_args+=("-r" "$recip")
        done
        age "${age_args[@]}"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -p
    else
        fatal "No encryption method configured"
    fi
}

__decrypt_stream() {
    if [[ -n "${AGE_KEY_FILE:-}" && -f "$AGE_KEY_FILE" ]]; then
        age -d -i "$AGE_KEY_FILE"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -d
    else
        fatal "No decryption key available"
    fi
}

_calculate_locker_checksum() {
    local locker_dir="$1"

    if [[ ! -d "$locker_dir" ]]; then
        echo "no-locker"
        return 0
    fi

    # Create a deterministic checksum of all files in the locker
    find "$locker_dir" -type f -exec md5sum {} \; 2>/dev/null | \
        sort -k2 | \
        md5sum | \
        cut -d' ' -f1
}

_validate_clamp_target() {
    local target_path="$1"
    if ! is_git_repo "$target_path"; then
        fatal "Target is not a git repository: $target_path"
    fi
    return 0
}

_setup_crypto_with_master() {
    local key_file="$1"
    local use_ignition="$2"
    local ignition_key="$3"

    AGE_KEY_FILE="$key_file"

    if [[ "$use_ignition" == "true" ]]; then
        AGE_PASSPHRASE="$ignition_key"
    else
        # Ensure the global master key exists to be added as a recipient.
        _ensure_master_key

        # Get the public key of the repo-specific key.
        local repo_recipient
        repo_recipient=$(age-keygen -y "$key_file" 2>/dev/null)

        # Get the public key of the global master key.
        local master_recipient
        master_recipient=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null)

        # Combine them. __encrypt_stream handles comma-separated lists.
        AGE_RECIPIENTS="$repo_recipient,$master_recipient"
        trace "Repo recipient: $repo_recipient"
        trace "Master recipient: $master_recipient"
    fi

    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"
}

# Guard function for chest mode
is_chest_repo() {
    [[ -d "$1/.chest" ]]
}

# State-getter for chest mode
get_chest_state() {
    if is_chest_repo "$REPO_ROOT"; then
        echo "locked"
    elif [[ -d "$REPO_ROOT/locker" ]]; then
        echo "unlocked"
    else
        echo "unknown"
    fi
}

# Wrapper for ignition lock process
_lock_chest() {
    if [[ ! -d "$REPO_ROOT/locker" ]]; then
        error "Locker directory not found, cannot lock chest."
        return 1
    fi
    info "üóÉÔ∏è  Securing locker in .chest..."

    # Load config from inside the locker to get recipients/passphrase
    source "$REPO_ROOT/locker/.padlock"

    # Encrypt locker directly into the chest
    local chest_blob="$REPO_ROOT/.chest/locker.age"
    mkdir -p "$REPO_ROOT/.chest"
    if tar -czf - -C "$REPO_ROOT" locker | __encrypt_stream > "$chest_blob"; then
        # Remove plaintext locker *after* success
        rm -rf "$REPO_ROOT/locker"
        okay "‚úì Chest locked. Plaintext locker removed."
        return 0
    else
        error "Failed to encrypt locker into chest."
        # Cleanup failed attempt
        rm -f "$chest_blob"
        return 1
    fi
}

# Wrapper for ignition unlock process
_unlock_chest() {
    local encrypted_ignition_key_blob="$REPO_ROOT/.chest/ignition.age"
    local chest_blob="$REPO_ROOT/.chest/locker.age"

    if [[ ! -f "$encrypted_ignition_key_blob" || ! -f "$chest_blob" ]]; then
        error "Chest is incomplete. Cannot unlock. Missing ignition.age or locker.age."
        return 1
    fi

    if [[ -z "${PADLOCK_IGNITION_PASS:-}" ]]; then
        error "Ignition key not found in environment variable PADLOCK_IGNITION_PASS."
        return 1
    fi

    info "üóÉÔ∏è  Unlocking locker from .chest using ignition passphrase..."

    # 1. Decrypt the ignition key into a temporary file.
    local temp_ignition_key
    temp_ignition_key=$(mktemp)
    trap "trace 'Cleaning up temp key file...'; rm -f -- '$temp_ignition_key'" RETURN

    AGE_PASSPHRASE="${PADLOCK_IGNITION_PASS}" age -d < "$encrypted_ignition_key_blob" > "$temp_ignition_key"
    if [[ $? -ne 0 || ! -s "$temp_ignition_key" ]]; then
        fatal "Failed to decrypt ignition key. Is the passphrase correct?"
    fi
    trace "Decrypted ignition key to temporary file."

    # 2. Use the decrypted ignition key to decrypt the locker.
    export AGE_KEY_FILE="$temp_ignition_key"
    export AGE_RECIPIENTS=""
    export AGE_PASSPHRASE=""

    if __decrypt_stream < "$chest_blob" | tar -xzf - -C "$REPO_ROOT"; then
        # Remove chest *after* successful decryption
        rm -rf "$REPO_ROOT/.chest"
        okay "‚úì Chest unlocked. Encrypted chest removed."
        return 0
    else
        error "Failed to decrypt locker from chest using ignition key."
        rm -rf "$REPO_ROOT/locker"
        return 1
    fi
}

_generate_ignition_key() {
    # Generate a memorable, 6-part passphrase from a curated wordlist using cryptographically secure random
    local words=("flame" "rocket" "boost" "spark" "launch" "fire" "power" "thrust" "ignite" "blast" "nova" "comet" "star" "orbit" "galaxy" "nebula")
    local key=""
    for i in {1..6}; do
        # Use shuf with /dev/urandom for cryptographically secure random selection
        local word_index
        if command -v shuf >/dev/null 2>&1; then
            word_index=$(shuf -i 0-$((${#words[@]}-1)) -n 1)
        else
            # Fallback using /dev/urandom directly if shuf not available
            word_index=$(od -An -N1 -tu1 < /dev/urandom | awk -v max=${#words[@]} '{print $1 % max}')
        fi
        key+="${words[$word_index]}"
        [[ $i -lt 6 ]] && key+="-"
    done
    echo "$key"
}

_setup_ignition_system() {
    local ignition_passphrase="${1}" # The memorable phrase

    info "üî• Setting up ignition system..."

    # 1. Generate the repository's master keypair. This will be encrypted.
    local ignition_key_file="$REPO_ROOT/.chest/ignition.key"
    mkdir -p "$REPO_ROOT/.chest"
    age-keygen -o "$ignition_key_file" >/dev/null
    trace "Generated ignition keypair at $ignition_key_file"

    # 2. Encrypt the new private key using the provided passphrase.
    local encrypted_ignition_key_blob="$REPO_ROOT/.chest/ignition.age"
    AGE_PASSPHRASE="$ignition_passphrase" age -p < "$ignition_key_file" > "$encrypted_ignition_key_blob"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to encrypt ignition key with passphrase."
    fi
    trace "Encrypted ignition key stored at $encrypted_ignition_key_blob"

    # 3. Get the public key of the new ignition key. This will be the recipient for the locker.
    local ignition_public_key
    ignition_public_key=$(age-keygen -y "$ignition_key_file")

    # 4. Clean up the plaintext private key.
    rm -f "$ignition_key_file"

    # 5. Set up the .padlock config file for future `ignite --lock` operations.
    export AGE_RECIPIENTS="$ignition_public_key"
    export AGE_KEY_FILE=""
    export AGE_PASSPHRASE=""
    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"

    okay "‚úì Ignition system configured."
    info "üîë Your ignition passphrase: $ignition_passphrase"
    warn "‚ö†Ô∏è  Share this passphrase for AI/automation access. Keep it safe."
}

_rotate_ignition_key() {
    local encrypted_ignition_key_blob="$REPO_ROOT/.chest/ignition.age"
    if [[ ! -f "$encrypted_ignition_key_blob" ]]; then
        error "Cannot rotate ignition key: chest is not locked or not an ignition repo."
        return 1
    fi

    # Prompt for the old passphrase
    local old_passphrase
    read -sp "Enter current ignition passphrase: " old_passphrase
    echo

    if [[ -z "$old_passphrase" ]]; then
        error "No passphrase provided. Aborting."
        return 1
    fi

    # Decrypt the key with the old passphrase
    local temp_ignition_key
    temp_ignition_key=$(mktemp)
    trap "rm -f -- '$temp_ignition_key'" RETURN

    AGE_PASSPHRASE="$old_passphrase" age -d < "$encrypted_ignition_key_blob" > "$temp_ignition_key"
    if [[ $? -ne 0 || ! -s "$temp_ignition_key" ]]; then
        fatal "Failed to decrypt ignition key. Is the passphrase correct?"
    fi

    # Generate a new passphrase
    local new_passphrase
    new_passphrase=$(_generate_ignition_key)

    # Re-encrypt the key with the new passphrase
    AGE_PASSPHRASE="$new_passphrase" age -p < "$temp_ignition_key" > "$encrypted_ignition_key_blob"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to re-encrypt ignition key."
    fi

    okay "‚úì Ignition key successfully rotated."
    info "üîë Your new ignition passphrase is: $new_passphrase"
    warn "‚ö†Ô∏è  Update any automated systems with this new passphrase."
}

_ensure_master_key() {
    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        info "üîë Generating global master key..."
        mkdir -p "$(dirname "$PADLOCK_GLOBAL_KEY")"
        age-keygen -o "$PADLOCK_GLOBAL_KEY" >/dev/null
        chmod 600 "$PADLOCK_GLOBAL_KEY"
        okay "‚úì Global master key created at: $PADLOCK_GLOBAL_KEY"
        warn "‚ö†Ô∏è  This key is your ultimate backup. Keep it safe."
    else
        trace "Global master key already exists."
    fi
}

__print_padlock_config() {
    local file="$1"
    local repo_name="$2"

    cat > "$file" << EOF
#!/bin/bash
# Padlock configuration for $repo_name
# This file is only present when locker is unlocked

export AGE_RECIPIENTS='${AGE_RECIPIENTS:-}'
export AGE_KEY_FILE='${AGE_KEY_FILE:-}'
export AGE_PASSPHRASE='${AGE_PASSPHRASE:-}'
export PADLOCK_REPO='$REPO_ROOT'

# Project-specific settings
export PROJECT_NAME='$repo_name'
EOF
}
# === 05_printers.sh ===
################################################################################
# File Printers - Low-Level Content Generation
################################################################################

__print_gitattributes() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock encryption" \
        "locker.age filter=locker-crypt" \
        "locker.age binary" \
        "" \
        "# Keep tools plaintext" \
        "bin/* -filter" \
        ".githooks/* -filter"
    
    printf "%s\n" "$content" > "$file"
}

__print_gitignore() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock - never commit plaintext locker" \
        "locker/"
    
    printf "%s\n" "$content" > "$file"
}

__print_age_wrapper() {
    local file="$1"
    local repo_root="$2"
    
    cat > "$file" << 'AGE_WRAPPER_EOF'
#!/usr/bin/env bash
set -euo pipefail

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

MODE="${1:-}"
REPO_ROOT="$(_find_root)"
CRYPTO_CONFIG="$REPO_ROOT/locker/.padlock"
LOCKER_DIR="$REPO_ROOT/locker"
LOCKER_BLOB="$REPO_ROOT/locker.age"

load_config() {
    if [[ -f "$CRYPTO_CONFIG" ]]; then
        source "$CRYPTO_CONFIG"
    else
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            echo "‚úó No crypto config. Run: bin/padlock setup" >&2
            exit 1
        fi
    fi
}

encrypt_locker() {
    if [[ ! -d "$LOCKER_DIR" ]]; then
        echo "No locker directory found" >&2
        exit 1
    fi
    
    load_config
    
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        tar -czf - -C "$REPO_ROOT" locker | age -r "$AGE_RECIPIENTS"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        tar -czf - -C "$REPO_ROOT" locker | age -p
    else
        echo "No encryption method configured" >&2
        exit 1
    fi
}

decrypt_locker() {
    load_config
    
    if [[ -n "${AGE_KEY_FILE:-}" ]]; then
        age -d -i "$AGE_KEY_FILE" | tar -xzf - -C "$REPO_ROOT"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        age -d -p | tar -xzf - -C "$REPO_ROOT"
    else
        echo "No decryption method available" >&2
        exit 1
    fi
}

case "$MODE" in
    encrypt)
        encrypt_locker
        ;;
    decrypt)
        decrypt_locker
        ;;
    *)
        echo "Usage: $0 {encrypt|decrypt}" >&2
        exit 1
        ;;
esac
AGE_WRAPPER_EOF

    chmod +x "$file"
}

__print_hook() {
    local file="$1"
    local hook_type="$2"
    local repo_root="$3"
    
    case "$hook_type" in
        pre-commit)
            cat > "$file" << 'PRE_COMMIT_EOF'
#!/usr/bin/env bash
# Pre-commit hook: Auto-encrypt locker if it exists

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_DIR="$REPO_ROOT/locker"

if [[ -d "$LOCKER_DIR" ]]; then
    echo "üîí Auto-encrypting locker before commit..."
    if "$REPO_ROOT/bin/padlock" lock; then
        echo "‚úì Locker encrypted successfully"
        git add locker.age .locked 2>/dev/null || true
    else
        echo "‚úó Failed to encrypt locker" >&2
        exit 1
    fi
fi

exit 0
PRE_COMMIT_EOF
            ;;
        post-checkout)
            cat > "$file" << 'POST_CHECKOUT_EOF'
#!/usr/bin/env bash
# Post-checkout hook: Auto-decrypt locker.age if it exists

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_BLOB="$REPO_ROOT/locker.age"

if [[ -f "$LOCKER_BLOB" ]] && [[ ! -d "$REPO_ROOT/locker" ]]; then
    echo "üîì Auto-decrypting locker after checkout..."
    if "$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "‚úì Locker decrypted successfully"
    else
        echo "‚ìò Locker remains encrypted (use: padlock unlock)"
    fi
fi

exit 0
POST_CHECKOUT_EOF
            ;;
        post-merge)
            cat > "$file" << 'POST_MERGE_EOF'
#!/usr/bin/env bash
# Post-merge hook: Refresh locker after merge

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_BLOB="$REPO_ROOT/locker.age"

if [[ -f "$LOCKER_BLOB" ]] && [[ -d "$REPO_ROOT/locker" ]]; then
    echo "üîÑ Refreshing locker after merge..."
    if "$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "‚úì Locker refreshed successfully"
    else
        echo "‚ìò Manual refresh needed (use: padlock unlock)"
    fi
fi

exit 0
POST_MERGE_EOF
            ;;
        post-commit)
            cat > "$file" << 'POST_COMMIT_EOF'
#!/usr/bin/env bash
# Post-commit hook: Verify encryption actually occurred

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"

# Check if locker.age was modified in this commit
if git diff --name-only HEAD~1..HEAD | grep -q "^locker\.age$"; then
    echo "üîç Verifying locker encryption..."
    
    # Check that locker.age is actually encrypted (contains age header)
    if head -c 30 "$REPO_ROOT/locker.age" 2>/dev/null | grep -q "age-encryption.org"; then
        echo "‚úì Locker encryption verified"
    else
        echo "‚ö†Ô∏è  WARNING: locker.age does not appear to be encrypted!"
        echo "‚ö†Ô∏è  This may indicate git filters were bypassed"
        echo "‚ö†Ô∏è  Check your git configuration and re-commit if needed"
    fi
    
    # Verify no plaintext locker directory was accidentally committed
    if git ls-files --error-unmatch locker/ >/dev/null 2>&1; then
        echo "üö® ERROR: Plaintext locker/ directory found in git!"
        echo "üö® This is a security breach - secrets are committed in plaintext"
        echo "üö® Run: git reset --soft HEAD~1 && git rm -r --cached locker/"
        exit 1
    fi
fi

exit 0
POST_COMMIT_EOF
            ;;
    esac
    
    chmod +x "$file"
}


__print_overdrive_file() {
    local file="$1"
    local super_checksum="$2"

    cat > "$file" << EOF
#!/bin/bash
# Overdrive unlock script
# Generated: $(date)
# Super checksum: $super_checksum

if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]; then
    echo "Usage: source .overdrive"
    exit 1
fi

echo "üöÄ Overdrive mode detected"
echo "üîì Unlocking entire repository..."

if bin/padlock overdrive unlock; then
    echo "‚úì Repository restored from overdrive mode"
    echo "‚ö†Ô∏è  Remember to commit/push any changes before next overdrive"
else
    echo "‚úó Failed to unlock overdrive mode"
fi
EOF
    chmod +x "$file"
}


__print_starter_files() {
    local locker_dir="$1"
    
    mkdir -p "$locker_dir/docs_sec" "$locker_dir/conf_sec"
    
    cat > "$locker_dir/docs_sec/AGENT.md" << 'AGENT_EOF'
# AI Agent Instructions

This file contains instructions for AI agents working on this project.

## System Prompt

You are an AI assistant working on this project. This content is encrypted 
and only visible when the repository locker is unlocked.

## Guidelines

- Follow project conventions
- Be helpful and concise
- Ask for clarification when needed

## Context

This file is part of the secure locker and will be encrypted in git.
Add your AI-specific instructions and context here.
AGENT_EOF
    
    cat > "$locker_dir/conf_sec/project.conf" << 'CONF_EOF'
# Project Configuration
# Secure configuration file - encrypted in git

# API Keys (example)
# API_KEY=your-secret-key
# DATABASE_URL=postgresql://user:pass@host/db

# Environment specific settings
ENV=development

# Add your secure configuration here
CONF_EOF
}

__print_security_readme() {
    local file="$1"
    
    cat > "$file" << 'SECURITY_EOF'
# Security Information

This repository uses **Padlock** for transparent encryption of sensitive files.

## How It Works

- **Locker Directory**: Sensitive files go in `locker/` (plaintext locally, never committed)
- **Encrypted Storage**: Git stores `locker.age` (encrypted binary blob)
- **State Files**: 
  - `.locked` exists when secrets are encrypted (run `bin/padlock unlock` to decrypt)
  - `locker/.padlock` exists when secrets are accessible (contains crypto config)

## Quick Start

```bash
# Setup encryption (first time)
bin/padlock setup

# Unlock secrets
bin/padlock unlock

# Lock secrets manually
bin/padlock lock

# Check status
bin/padlock status
```

## Directory Structure

```
locker/
‚îú‚îÄ‚îÄ docs_sec/           # Secure documentation
‚îú‚îÄ‚îÄ conf_sec/           # Configuration files, API keys
‚îî‚îÄ‚îÄ .padlock           # Crypto configuration (unlocked state)
```

## Commands

- `bin/padlock status` - Check lock/unlock state
- `bin/padlock lock` - Encrypt locker/ ‚Üí locker.age
- `bin/padlock unlock` - Decrypt locker.age ‚Üí locker/
- `bin/padlock setup` - Initial encryption setup

## Team Sharing

```bash
# Add team member's public key
bin/padlock key --add-recipient age1abc123...

# Generate your public key to share
bin/padlock key --show-global
```

## Master Key Emergency Access

This repository includes a master key backup recipient. If you lose access to your 
regular keys, you can unlock using:

```bash
padlock master-unlock
```

## Ignition Keys (AI Collaboration)

If this repository uses ignition mode, you can share the ignition passphrase 
with AI assistants for automated access:

```bash
export PADLOCK_IGNITION_PASS="your-ignition-key"
bin/padlock unlock
```

## Notes

- Files in `locker/` are automatically encrypted on commit
- `locker.age` is automatically decrypted on checkout
- Remove this file once you're familiar with the system
- Never commit the `locker/` directory - it's in `.gitignore`

Created by Padlock v1.0.0
SECURITY_EOF
}

# === 06_api.sh ===
do_clamp() {
    local target_path="${1:-.}"
    local use_global_key=false
    local generate_key=false
    local explicit_key=""
    local use_ignition=false
    local ignition_key=""
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global-key) 
                use_global_key=true
                shift
                ;;
            --generate) 
                generate_key=true
                shift
                ;;
            --key)
                if [[ $# -lt 2 ]]; then fatal "--key option requires an argument"; fi
                explicit_key="$2"
                shift 2
                ;;
            -K|--ignition)
                use_ignition=true
                if [[ $# -gt 1 && -n "${2:-}" && "$2" != -* ]]; then
                    ignition_key="$2"
                    shift 2
                else
                    shift
                fi
                ;;
            *) 
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done
    
    target_path="$(realpath "$target_path")"
    info "Deploying padlock to: $target_path"
    
    # Enhanced validation with helpful errors
    if ! _validate_clamp_target "$target_path"; then
        return 1
    fi
    
    # Set up paths
    REPO_ROOT="$(_get_repo_root "$target_path")"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    lock "üîß Setting up padlock structure..."
    
    # Enhanced age validation with helpful errors
    if ! _validate_age_installation; then
        return 1
    fi
    
    # Create bin directory and copy tools
    mkdir -p "$REPO_ROOT/bin"
    
    # Copy self to target repo
    cp "$SCRIPT_PATH" "$REPO_ROOT/bin/padlock"
    chmod +x "$REPO_ROOT/bin/padlock"
    trace "Copied padlock to bin/"
    
    # Create age-wrapper
    __print_age_wrapper "$REPO_ROOT/bin/age-wrapper" "$REPO_ROOT"
    trace "Created age-wrapper"
    
    # Create .githooks directory and hooks
    mkdir -p "$REPO_ROOT/.githooks"
    __print_hook "$REPO_ROOT/.githooks/pre-commit" "pre-commit" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-checkout" "post-checkout" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-merge" "post-merge" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-commit" "post-commit" "$REPO_ROOT"
    trace "Created git hooks"
    
    # Configure git integration
    __print_gitattributes "$REPO_ROOT/.gitattributes"
    __print_gitignore "$REPO_ROOT/.gitignore"
    
    # Git configuration
    git -C "$REPO_ROOT" config core.hooksPath .githooks
    git -C "$REPO_ROOT" config filter.locker-crypt.clean 'bin/age-wrapper encrypt'
    git -C "$REPO_ROOT" config filter.locker-crypt.smudge 'bin/age-wrapper decrypt'
    trace "Configured git filters"
    
    lock "üîë Setting up encryption..."
    
    # Determine key strategy
    local repo_key_file
    if [[ -n "$explicit_key" ]]; then
        repo_key_file="$explicit_key"
        trace "Using explicit key: $repo_key_file"
    elif [[ "$use_global_key" == true ]]; then
        repo_key_file="$PADLOCK_GLOBAL_KEY"
        if [[ ! -f "$repo_key_file" ]]; then
            info "üîë Generating global key..."
            age-keygen > "$repo_key_file"
            chmod 600 "$repo_key_file"
        fi
        trace "Using global key"
    else
        # Generate repository-specific key
        repo_key_file="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        if [[ ! -f "$repo_key_file" ]]; then
            info "üîë Generating repository key..."
            age-keygen > "$repo_key_file"
            chmod 600 "$repo_key_file"
        fi
        trace "Using repo-specific key"
    fi
    
    # Create locker directory structure
    mkdir -p "$LOCKER_DIR"
    
    # Enhanced crypto setup with master key integration
    if [[ "$use_ignition" == true ]]; then
        # Generate ignition passphrase if not provided by the user
        if [[ -z "$ignition_key" ]]; then
            ignition_key="$(_generate_ignition_key)"
        fi
        
        # Call the new ignition system setup helper
        _setup_ignition_system "$ignition_key"
        
        # Add to manifest as ignition type
        _add_to_manifest "$REPO_ROOT" "ignition"
        
    else
        # Standard mode with master key backup
        _setup_crypto_with_master "$repo_key_file" "false" ""
        info "üîê Standard mode configured"
        
        # Add to manifest as standard type
        _add_to_manifest "$REPO_ROOT" "standard"
    fi
    
    # Create starter files
    __print_starter_files "$LOCKER_DIR"
    __print_security_readme "$REPO_ROOT/SECURITY.md"
    trace "Created starter files"
    
    # Final success message
    okay "‚úì Padlock deployed successfully"
    
    # Show next steps based on mode
    echo
    printf "%bNext steps:%b\n" "$cyan" "$xx"
    if [[ "$use_ignition" == true ]]; then
        printf "  ‚Ä¢ üî• Ignition key: %b%s%b\n" "$cyan" "$ignition_key" "$xx"
        echo "  ‚Ä¢ Share this key for AI/automation access"
        echo "  ‚Ä¢ Edit files in locker/ or use chest mode"
    else
        echo "  ‚Ä¢ Edit files in locker/docs_sec/ and locker/conf_sec/"
        echo "  ‚Ä¢ Run 'git add . && git commit' to encrypt"
    fi
    echo "  ‚Ä¢ üóùÔ∏è  Master key configured as backup"
    echo "  ‚Ä¢ Run 'bin/padlock status' to check state"
}

do_status() {
    local repo_root="$(_get_repo_root .)"
    
    if [[ ! -d "$repo_root" ]]; then
        error "Not in a git repository"
        return 1
    fi
    
    info "Repository status: $repo_root"
    
    if [[ -d "$repo_root/locker" && -f "$repo_root/locker/.padlock" ]]; then
        okay "üîì UNLOCKED - Secrets accessible in locker/"
        info "üìù Files ready for editing"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Edit files in locker/"
        echo "  ‚Ä¢ Run 'git commit' (auto-locks on commit)"
        echo "  ‚Ä¢ Manual lock: bin/padlock lock"
        
    elif [[ -f "$repo_root/.locked" && -f "$repo_root/locker.age" ]]; then
        warn "üîí LOCKED - Secrets encrypted in locker.age"
        local size
        size=$(du -h "$repo_root/locker.age" 2>/dev/null | cut -f1 || echo "unknown")
        info "üì¶ Encrypted size: $size"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ To unlock, run: padlock unlock"
        
    elif [[ -d "$repo_root/.chest" ]]; then
        warn "üóÉÔ∏è  CHEST MODE - Advanced encryption active"
        info "üì¶ Ignition key system detected"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Run: bin/padlock ignite --unlock"
        echo "  ‚Ä¢ With: PADLOCK_IGNITION_PASS=your-key"
        
    else
        error "‚ùì UNKNOWN STATE - Padlock not properly configured"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Run: bin/padlock setup"
        echo "  ‚Ä¢ Or:  padlock clamp . --generate"
    fi
    
    # Show files count if unlocked
    if [[ -d "$repo_root/locker" ]]; then
        local file_count
        file_count=$(find "$repo_root/locker" -type f | wc -l)
        trace "üìÅ Files in locker: $file_count"
    fi
}

do_lock() {
    # Early validation
    if [[ ! -d "$PWD/locker" ]]; then
        error "No locker directory found"
        info "Run 'padlock clamp' first to set up encryption"
        return 1
    fi
    
    if [[ ! -f "$PWD/locker/.padlock" ]]; then
        error "Locker not properly configured"
        info "Missing .padlock config file"
        return 1
    fi
    
    # Load configuration
    # shellcheck source=/dev/null
    source "$PWD/locker/.padlock"
    
    if [[ -z "${AGE_RECIPIENTS:-}" && -z "${AGE_PASSPHRASE:-}" ]]; then
        error "No encryption method configured (recipients or passphrase)"
        return 1
    fi
    
    lock "üîí Encrypting locker directory..."
    
    # Calculate file count before locking
    local file_count
    file_count=$(find locker -type f | wc -l)
    trace "üìÅ Files to encrypt: $file_count"
    
    # Create archive and encrypt to a secure temporary file
    local temp_blob
    temp_blob=$(mktemp "$(dirname "$PWD/locker.age")/locker.age.XXXXXX")
    tar -czf - locker | __encrypt_stream > "$temp_blob"

    # Check if encryption was successful before proceeding
    if [[ $? -eq 0 && -s "$temp_blob" ]]; then
        # Encryption successful, proceed with replacing old blob and removing plaintext
        mv "$temp_blob" "locker.age"
        local size
        size=$(du -h locker.age | cut -f1)
        okay "‚úì Locked: locker/ ‚Üí locker.age ($size)"
        
        # Calculate checksum
        local checksum
        checksum=$(find locker -type f -exec md5sum {} \; 2>/dev/null | sort | md5sum | cut -d' ' -f1)

        # Calculate checksum of the original content and save it
        local checksum
        checksum=$(_calculate_locker_checksum "locker")
        echo "$checksum" > .locker_checksum
        trace "Saved checksum: $checksum"

        # Create a simple state file to indicate locked status
        touch .locked
        

        # Remove plaintext locker *after* successful encryption and move
        rm -rf locker
        
        info "Repository locked successfully."
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ git add . && git commit"
        echo "  ‚Ä¢ To unlock, run: padlock unlock"
        warn "‚ö†Ô∏è  Secrets are now encrypted and safe to commit"
        
    else
        # Encryption failed, clean up temporary file and abort
        rm -f "$temp_blob"
        fatal "Failed to encrypt locker directory. Plaintext data remains untouched."
    fi
}

do_unlock() {
    # Early validation
    if [[ ! -f "locker.age" ]]; then
        error "No encrypted locker found (locker.age missing)"
        info "Repository may already be unlocked"
        return 1
    fi

    if [[ -d "locker" ]]; then
        warn "Locker directory already exists"
        info "Repository appears to be unlocked"
        return 0
    fi

    # Determine key file path, preferring env var if set, otherwise derive it
    local key_file="${AGE_KEY_FILE:-}"
    if [[ -z "$key_file" ]]; then
        local repo_root
        repo_root=$(_get_repo_root .)
        key_file="$PADLOCK_KEYS/$(basename "$repo_root").key"

        if [[ ! -f "$key_file" ]]; then
            error "Could not find default decryption key for this repository."
            info "Looked for key at: $key_file"
            info "You can also set the AGE_KEY_FILE environment variable manually."
            return 1
        fi
        trace "Using derived repository key: $key_file"
    else
        trace "Using key from AGE_KEY_FILE env var: $key_file"
    fi

    lock "üîì Decrypting locker.age..."

    # Decrypt and extract using the determined key file
    if age -d -i "$key_file" < locker.age | tar -xzf -; then
        local file_count
        file_count=$(find locker -type f | wc -l)
        okay "‚úì Unlocked: locker.age ‚Üí locker/ ($file_count files)"

        # Verify integrity against the stored checksum
        if [[ -f ".locker_checksum" ]]; then
            local expected_checksum
            expected_checksum=$(cat .locker_checksum)
            local current_checksum
            current_checksum=$(_calculate_locker_checksum "locker")

            trace "Verifying checksum. Expected: $expected_checksum, Current: $current_checksum"
            if [[ "$expected_checksum" == "$current_checksum" ]]; then
                okay "‚úì Locker integrity verified."
            else
                error "üîí Integrity check FAILED. Contents may have been tampered with."
                info "Expected: $expected_checksum"
                info "Current:  $current_checksum"
                if [[ "${opt_force:-0}" -eq 1 ]]; then
                    warn "‚ö†Ô∏è  --force flag used, continuing despite integrity failure"
                else
                    fatal "Use --force to override integrity check and unlock anyway"
                fi
            fi
        fi

        # Clean up encrypted file and state indicators
        rm -f locker.age .locked .locker_checksum

        info "Repository unlocked successfully. Your shell session is not affected."
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Edit files in the 'locker' directory."
        echo "  ‚Ä¢ Run 'git commit' to auto-lock when done."
        warn "‚ö†Ô∏è  Secrets are now in plaintext. The 'locker/' directory is in .gitignore."

    else
        fatal "Failed to decrypt locker.age. Check your key permissions or repository state."

    fi
}

do_clean_manifest() {
    local manifest_file="$PADLOCK_ETC/manifest.txt"

    if [[ ! -f "$manifest_file" || ! -s "$manifest_file" ]]; then
        info "Manifest is empty or not found. Nothing to clean."
        return
    fi

    local temp_file
    temp_file=$(mktemp)

    # Preserve header
    grep "^#" "$manifest_file" > "$temp_file"

    # Use a temporary variable to store the lines to keep
    local lines_to_keep=""
    while IFS= read -r line; do
        # Skip comments
        [[ "$line" =~ ^# ]] && continue

        # Parse the line
        IFS='|' read -r namespace name path type remote checksum created access metadata <<< "$line"

        # Keep if the path exists and is not a temp path
        if [[ -d "$path" && "$metadata" != *"temp=true"* && "$path" != */tmp/* ]]; then
            lines_to_keep+="$line\n"
        else
            trace "Pruning from manifest: $namespace/$name ($path)"
        fi
    done < "$manifest_file"

    # Write the kept lines to the temp file
    printf "%b" "$lines_to_keep" >> "$temp_file"

    mv "$temp_file" "$manifest_file"
    okay "‚úì Manifest cleaned"
}

do_list() {
    local filter="$1"
    local manifest_file="$PADLOCK_ETC/manifest.txt"

    if [[ ! -f "$manifest_file" || ! -s "$manifest_file" ]]; then
        info "Manifest is empty or not found. No repositories tracked yet."
        return
    fi

    case "$filter" in
        --all)
            awk -F'|' '!/^#/ { printf "%-15s %-20s %s (%s)\n", $1, $2, $3, $4 }' "$manifest_file"
            ;;
        --ignition)
            awk -F'|' '!/^#/ && $4 == "ignition" && $9 !~ /temp=true/ { printf "%-15s %-20s %s\n", $1, $2, $3 }' "$manifest_file"
            ;;
        --namespace)
            local ns="$2"
            awk -F'|' -v namespace="$ns" '!/^#/ && $1 == namespace && $9 !~ /temp=true/ { printf "%-20s %s (%s)\n", $2, $3, $4 }' "$manifest_file"
            ;;
        *)
            # Default: exclude temp directories, show namespace/name/path
            awk -F'|' '!/^#/ && $9 !~ /temp=true/ && $3 !~ /\/tmp\// { printf "%-15s %-20s %s (%s)\n", $1, $2, $3, $4 }' "$manifest_file"
            ;;
    esac
}

# Enhanced manifest management
_add_to_manifest() {
    local repo_path="$1"
    local repo_type="${2:-standard}"
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    local now
    now=$(date -Iseconds 2>/dev/null || date)
    
    # Create header if empty
    if [[ ! -s "$manifest_file" ]]; then
        mkdir -p "$(dirname "$manifest_file")"
        echo "# Padlock Repository Manifest v2.0" > "$manifest_file"
        echo "# Format: namespace|name|path|type|remote|checksum|created|last_access|metadata" >> "$manifest_file"
    fi
    
    # Extract repository information
    local repo_name
    repo_name=$(basename "$repo_path")
    local namespace="local"
    local remote_url=""
    local checksum=""
    
    # Get git remote if available
    if [[ -d "$repo_path/.git" ]]; then
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Extract namespace and repo name from remote URL
            if [[ "$remote_url" =~ github\.com[/:]([^/]+)/([^/]+) ]]; then
                namespace="${BASH_REMATCH[1]}"
                repo_name="${BASH_REMATCH[2]%.git}"
            elif [[ "$remote_url" =~ gitlab\.com[/:]([^/]+)/([^/]+) ]]; then
                namespace="${BASH_REMATCH[1]}"
                repo_name="${BASH_REMATCH[2]%.git}"
            else
                namespace="remote"
            fi
        fi
    fi
    
    # Generate repository checksum for integrity tracking
    checksum=$(echo "$repo_path|$repo_type|$now" | sha256sum | cut -d' ' -f1 | head -c 12)
    
    # Skip if path already exists in manifest
    if grep -q "|$repo_path|" "$manifest_file" 2>/dev/null; then
        trace "Manifest entry for $repo_path already exists. Skipping."
        return 0
    fi

    # Detect temp directories to add metadata
    local metadata=""
    if [[ "$repo_path" == */tmp/* ]] || [[ "$repo_path" == */temp/* ]]; then
        metadata="temp=true"
    fi


    # Add new entry
    echo "$namespace|$repo_name|$repo_path|$repo_type|$remote_url|$checksum|$now|$now|$metadata" >> "$manifest_file"
    trace "Added manifest entry for $repo_path"
}

# Master unlock command
do_master_unlock() {
    lock "üîë Unlocking with master key..."
    if ! _master_unlock; then
        return 1
    fi
    
    okay "‚úì Repository unlocked with master key"
    info "üìù Environment loaded and ready"
    warn "‚ö†Ô∏è  Secrets are now in plaintext - DO NOT commit locker/"
}

_master_unlock() {
    # Check if the global key exists
    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        error "Master key not found at: $PADLOCK_GLOBAL_KEY"
        info "This key is usually generated automatically on first install."
        info "Try running 'padlock install' to generate it."
        return 1
    fi

    # Early validation for locker.age
    if [[ ! -f "locker.age" ]]; then
        error "No encrypted locker found (locker.age missing)."
        info "Cannot perform master unlock without locker.age."
        return 1
    fi

    # Use the global key for decryption by setting AGE_KEY_FILE for __decrypt_stream
    export AGE_KEY_FILE="$PADLOCK_GLOBAL_KEY"

    info "Attempting decryption with master key..."
    if __decrypt_stream < locker.age | tar -xzf -; then
        rm -f locker.age .locked
        info "Successfully unlocked with master key."
        unset AGE_KEY_FILE
        return 0
    else
        error "Failed to decrypt locker.age with master key."
        unset AGE_KEY_FILE
        return 1
    fi
}

# Placeholders for unimplemented ignition features
_ignition_lock() {
    error "Ignition lock feature not implemented."
    return 1
}
_chest_status() {
    error "Chest status feature not implemented."
    return 1
}

_ignition_unlock() {
    if [[ -z "${PADLOCK_IGNITION_PASS:-}" ]]; then
        error "Ignition key not found in environment variable PADLOCK_IGNITION_PASS."
        return 1
    fi

    if [[ ! -f "locker.age" ]]; then
        error "No encrypted locker found (locker.age missing)."
        return 1
    fi

    # Use the ignition pass as the age passphrase for decryption
    export AGE_PASSPHRASE="$PADLOCK_IGNITION_PASS"

    if __decrypt_stream < locker.age | tar -xzf -; then
        rm -f locker.age .locked
        return 0
    else
        error "Failed to decrypt locker.age with ignition key."
        return 1
    fi
}

# Ignition unlock command
do_ignite() {
    local action="$1"
    
    # Set REPO_ROOT for the helpers, as this is a top-level command.
    REPO_ROOT=$(_get_repo_root .)

    case "$action" in
        --unlock|-u)
            _unlock_chest
            ;;
        --lock|-l)
            _lock_chest
            ;;
        --status|-s)
            # Simple status for now, can be enhanced later.
            if [[ -d "$REPO_ROOT/.chest" ]]; then
                info "Chest is LOCKED."
            elif [[ -d "$REPO_ROOT/locker" ]]; then
                info "Chest is UNLOCKED."
            else
                info "Chest status is unknown (not an ignition repo?)."
            fi
            ;;
        *)
            error "Unknown ignition action: $action"
            info "Available actions: --unlock, --lock, --status"
            return 1
            ;;
    esac
}

do_rotate() {
    local target="$1"

    # Set REPO_ROOT for the helpers
    REPO_ROOT=$(_get_repo_root .)

    case "$target" in
        -K|--ignition)
            _rotate_ignition_key
            ;;
        *)
            error "Unknown target for rotate: $target"
            info "Usage: padlock rotate --ignition"
            return 1
            ;;
    esac
}


do_export() {
    local export_file="${1:-padlock_export_$(date +%Y%m%d_%H%M%S).tar.age}"
    local passphrase

    # Prompt for a passphrase to secure the export
    read -sp "Create a passphrase for the export file: " passphrase
    echo
    if [[ -z "$passphrase" ]]; then
        fatal "Passphrase cannot be empty."
    fi

    # Check if there is anything to export
    if [[ ! -d "$PADLOCK_KEYS" || -z "$(ls -A "$PADLOCK_KEYS")" ]]; then
        error "No keys found to export."
        return 1
    fi
    if [[ ! -f "$PADLOCK_ETC/manifest.txt" ]]; then
        error "Manifest not found. Nothing to export."
        return 1
    fi

    info "üì¶ Exporting padlock environment..."

    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "$temp_dir"' RETURN

    local export_manifest="$temp_dir/manifest.txt"
    local keys_dir="$temp_dir/keys"

    # Copy manifest and keys to a temporary location
    cp "$PADLOCK_ETC/manifest.txt" "$export_manifest"
    cp -r "$PADLOCK_KEYS" "$keys_dir"

    # Create metadata file
    cat > "$temp_dir/export_info.json" << EOF
{
    "version": "1.0",
    "exported_at": "$(date -Iseconds)",
    "exported_by": "$(whoami)@$(hostname)",
    "padlock_version": "$PADLOCK_VERSION"
}
EOF

    # Create a tarball and encrypt it with the passphrase
    tar -C "$temp_dir" -czf - . | AGE_PASSPHRASE="$passphrase" age -p > "$export_file"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to create encrypted export file."
    fi

    okay "‚úì Padlock environment successfully exported to: $export_file"
    warn "‚ö†Ô∏è  Keep this file and your passphrase safe!"
}

_merge_manifests() {
    local import_manifest="$1"
    local current_manifest="$2"
    local temp_file
    temp_file=$(mktemp)

    # Preserve header from current manifest if it exists
    if [[ -f "$current_manifest" ]]; then
        grep "^#" "$current_manifest" > "$temp_file"
    else
        # Or take header from import file
        grep "^#" "$import_manifest" > "$temp_file"
    fi

    # Merge entries (avoid duplicates by checking path column, which is column 3)
    {
        grep -v "^#" "$current_manifest" 2>/dev/null || true
        grep -v "^#" "$import_manifest"
    } | sort -t'|' -k3,3 -u >> "$temp_file"

    mv "$temp_file" "$current_manifest"
}

do_import() {
    local import_file="$1"
    local merge_mode="${2:---merge}"
    local passphrase="${3:-}" # Accept passphrase as 3rd arg

    if [[ ! -f "$import_file" ]]; then
        fatal "Import file not found: $import_file"
    fi

    if [[ -z "$passphrase" ]]; then
        read -sp "Enter passphrase for import file: " passphrase
        echo
        if [[ -z "$passphrase" ]]; then
            fatal "Passphrase cannot be empty."
        fi
    fi

    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "$temp_dir"' RETURN

    # Decrypt and extract
    if ! AGE_PASSPHRASE="$passphrase" age -d < "$import_file" | tar -C "$temp_dir" -xzf -; then
        fatal "Failed to decrypt import file (wrong passphrase?)"
    fi

    # Validate import
    if [[ ! -f "$temp_dir/export_info.json" || ! -f "$temp_dir/manifest.txt" ]]; then
        fatal "Invalid padlock export file."
    fi

    info "Successfully decrypted export file."

    # Backup current state
    local backup_dir="$PADLOCK_ETC/backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    if [[ -d "$PADLOCK_ETC" ]]; then
        cp -a "$PADLOCK_ETC"/* "$backup_dir/" 2>/dev/null || true
    fi
    info "Current environment backed up to: $backup_dir"

    # Import based on mode
    case "$merge_mode" in
        --replace)
            warn "Replacing current padlock environment."
            rm -f "$PADLOCK_ETC/manifest.txt"
            rm -rf "$PADLOCK_KEYS"
            mkdir -p "$PADLOCK_KEYS"
            cp "$temp_dir/manifest.txt" "$PADLOCK_ETC/manifest.txt"
            cp -r "$temp_dir/keys"/* "$PADLOCK_KEYS/"
            ;;
        --merge)
            info "Merging with current environment."
            _merge_manifests "$temp_dir/manifest.txt" "$PADLOCK_ETC/manifest.txt"
            cp -rT "$temp_dir/keys" "$PADLOCK_KEYS" 2>/dev/null || true
            ;;
        *)
            fatal "Unknown import mode: $merge_mode. Use --merge or --replace."
            ;;
    esac

    okay "‚úì Import completed successfully."
}

do_snapshot() {
    local snapshot_name="${1:-auto_$(date +%Y%m%d_%H%M%S)}"
    local snapshots_dir="$PADLOCK_ETC/snapshots"

    mkdir -p "$snapshots_dir"

    # Use a temporary, non-guessable passphrase for the snapshot export
    local snapshot_pass
    snapshot_pass=$(openssl rand -base64 32)

    local export_file="$snapshots_dir/${snapshot_name}.tar.age"

    info "Creating snapshot: $snapshot_name"

    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "$temp_dir"' RETURN

    cp "$PADLOCK_ETC/manifest.txt" "$temp_dir/manifest.txt"
    cp -r "$PADLOCK_KEYS" "$temp_dir/keys"

    tar -C "$temp_dir" -czf - . | AGE_PASSPHRASE="$snapshot_pass" age -p > "$export_file"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to create snapshot export file."
    fi

    # Create snapshot metadata, including the passphrase
    cat > "$snapshots_dir/${snapshot_name}.info" << EOF
name=$snapshot_name
created=$(date -Iseconds)
passphrase=$snapshot_pass
repos=$(grep -cv "^#" "$PADLOCK_ETC/manifest.txt")
keys=$(find "$PADLOCK_KEYS" -name "*.key" | wc -l)
EOF

    okay "‚úì Snapshot created: $snapshot_name"
}

do_rewind() {
    local snapshot_name="$1"
    local snapshots_dir="$PADLOCK_ETC/snapshots"

    if [[ ! -f "$snapshots_dir/${snapshot_name}.tar.age" || ! -f "$snapshots_dir/${snapshot_name}.info" ]]; then
        error "Snapshot not found: $snapshot_name"
        info "Available snapshots:"
        ls -1 "$snapshots_dir"/*.info 2>/dev/null | sed 's/\.info$//' | xargs -I {} basename {} || echo " (none)"
        return 1
    fi

    warn "This will ERASE your current padlock environment and restore the snapshot."
    read -p "Type the snapshot name to confirm: '$snapshot_name': " confirm
    if [[ "$confirm" != "$snapshot_name" ]]; then
        info "Rewind cancelled."
        return 0
    fi

    # Get the passphrase from the metadata file
    local snapshot_pass
    snapshot_pass=$(grep "^passphrase=" "$snapshots_dir/${snapshot_name}.info" | cut -d'=' -f2)

    # Call do_import with the correct arguments for non-interactive restore
    do_import "$snapshots_dir/${snapshot_name}.tar.age" --replace "$snapshot_pass"

    okay "‚úì Rewound to snapshot: $snapshot_name"
}

do_install() {
    local force="${1:-0}"
    
    # Check if already installed
    local install_dir="$XDG_LIB_HOME/fx/padlock"
    local link_path="$XDG_BIN_HOME/fx/padlock"
    
    if [[ -d "$install_dir" ]] && [[ "$force" -eq 1 ]]; then
        warn "Padlock already installed (use --force to reinstall)"
        return 0
    fi
    
    info "Installing padlock to system..."
    
    # Create installation directories
    mkdir -p "$(dirname "$install_dir")" "$(dirname "$link_path")"
    
    # Copy script to installation location
    cp -r "$(dirname "$SCRIPT_PATH")" "$install_dir"
    
    # Create symlink
    ln -sf "$install_dir/$(basename "$SCRIPT_PATH")" "$link_path"
    
    # Generate master key on first install
    _ensure_master_key
    
    okay "‚úì Padlock installed to: $install_dir"
    info "Available as: $link_path"
    info "üóùÔ∏è  Global master key configured"
}

_overdrive_unlock() {
    REPO_ROOT=$(_get_repo_root .)

    if [[ ! -f "$REPO_ROOT/super_chest.age" ]]; then
        error "Repository not in overdrive mode"
        return 1
    fi

    lock "üîì Disengaging overdrive mode..."

    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        error "Master key not found, cannot unlock overdrive mode."
        info "Ensure your master key is available at $PADLOCK_GLOBAL_KEY"
        return 1
    fi
    export AGE_KEY_FILE="$PADLOCK_GLOBAL_KEY"

    local super_chest="$REPO_ROOT/.super_chest"
    if ! __decrypt_stream < "$REPO_ROOT/super_chest.age" | tar -C "$REPO_ROOT" -xzf -; then
        fatal "Failed to decrypt super_chest.age"
    fi

    if [[ -f "$REPO_ROOT/.overdrive" ]]; then
        local expected_checksum
        expected_checksum=$(grep "Super checksum:" "$REPO_ROOT/.overdrive" | cut -d' ' -f4)
        local current_checksum
        current_checksum=$(_calculate_locker_checksum "$super_chest")

        if [[ "$current_checksum" != "$expected_checksum" ]]; then
            warn "‚ö†Ô∏è  Super chest integrity check failed!"
        else
            trace "‚úì Super chest integrity verified"
        fi
    fi

    cp -rT "$super_chest/" "$REPO_ROOT/"

    rm -rf "$super_chest"
    rm -f "$REPO_ROOT/super_chest.age"
    rm -f "$REPO_ROOT/.overdrive"

    okay "üîì Overdrive disengaged! Repository restored."
}

_overdrive_status() {
    REPO_ROOT=$(_get_repo_root .)

    info "=== Overdrive Status ==="

    if [[ -f "$REPO_ROOT/super_chest.age" ]]; then
        local size
        size=$(du -h "$REPO_ROOT/super_chest.age" 2>/dev/null | cut -f1)
        warn "üöÄ OVERDRIVE ENGAGED"
        info "Blob: super_chest.age ($size)"
        info "To restore: source .overdrive"
    else
        okay "‚úÖ NORMAL MODE"
        info "To engage: padlock overdrive lock"
    fi
}

_overdrive_lock() {
    REPO_ROOT=$(_get_repo_root .)

    if [[ -f "$REPO_ROOT/super_chest.age" ]]; then
        error "Repository already in overdrive mode"
        return 1
    fi

    if [[ ! -d "$REPO_ROOT/locker" ]]; then
        fatal "Locker must be unlocked to engage overdrive mode."
    fi

    lock "üöÄ Engaging overdrive mode..."

    # Create super_chest directory for staging
    local super_chest="$REPO_ROOT/.super_chest"
    mkdir -p "$super_chest"

    trap 'rm -rf "$super_chest"' EXIT

    # Use tar to copy files, which is more reliable than rsync for this case
    info "Archiving entire repository..."
    tar -c --exclude-from <(printf "%s\n" \
        ".super_chest" \
        "bin" \
        ".chest" \
        "super_chest.age" \
        ".locked" \
        ".ignition.key" \
        ".git" \
        ".gitsim" \
        ".locker_checksum" \
        "locker.age" \
    ) -C "$REPO_ROOT" . | tar -x -C "$super_chest"

    source "$REPO_ROOT/locker/.padlock"

    local super_checksum
    super_checksum=$(_calculate_locker_checksum "$super_chest")

    tar --sort=name --mtime='@0' --owner=0 --group=0 --numeric-owner \

        -C "$super_chest" -czf - . | __encrypt_stream > "$REPO_ROOT/super_chest.age"

    # Remove everything except padlock infrastructure and super_chest.age
    find "$REPO_ROOT" -maxdepth 1 -mindepth 1 \
        ! -name ".super_chest" \

        ! -name "bin" \
        ! -name ".chest" \
        ! -name ".git" \
        ! -name ".gitsim" \
        ! -name "super_chest.age" \
        -exec rm -rf {} +

    __print_overdrive_file "$REPO_ROOT/.overdrive" "$super_checksum"

    local size
    size=$(du -h "$REPO_ROOT/super_chest.age" | cut -f1)
    okay "üöÄ Overdrive engaged! Entire repo ‚Üí super_chest.age ($size)"
}

do_overdrive() {
    local action="${1:-lock}"

    case "$action" in
        lock) _overdrive_lock ;;
        unlock)
            _overdrive_unlock
            ;;
        status)
            _overdrive_status
            ;;
        *)
            error "Unknown overdrive action: $action"
            info "Usage: padlock overdrive {lock|unlock|status}"
            return 1
            ;;
    esac
}

# Setup command - alias for clamp with common defaults
do_setup() {
    local target_path="${1:-.}"
    
    info "üîß Setting up padlock in current repository..."
    
    # Default to generating a new key for setup
    do_clamp "$target_path" --generate
}

# Key management commands
do_key() {
    local action="$1"
    shift
    
    case "$action" in
        --set-global)
            local key_file="$1"
            if [[ ! -f "$key_file" ]]; then
                fatal "Key file not found: $key_file"
            fi
            
            info "üîë Setting global master key..."
            mkdir -p "$(dirname "$PADLOCK_GLOBAL_KEY")"
            cp "$key_file" "$PADLOCK_GLOBAL_KEY"
            chmod 600 "$PADLOCK_GLOBAL_KEY"
            okay "‚úì Global master key set"
            ;;
        --show-global)
            if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
                error "No global master key found"
                info "Run: padlock key --generate-global"
                return 1
            fi
            
            local public_key
            public_key=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null)
            echo "$public_key"
            ;;
        --generate-global)
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]] && [[ "${2:-}" != "--force" ]]; then
                error "Global master key already exists"
                info "Use --force to overwrite"
                return 1
            fi
            
            _ensure_master_key
            okay "‚úì Global master key generated"
            ;;
        --add-recipient)
            local recipient="$1"
            if [[ -z "$recipient" ]]; then
                fatal "--add-recipient requires a public key"
            fi
            
            # Check if we're in a repo with locker config
            if [[ ! -f "locker/.padlock" ]]; then
                error "Not in an unlocked padlock repository"
                info "Run 'padlock unlock' first"
                return 1
            fi
            
            # Load current config
            source "locker/.padlock"
            
            # Add recipient to existing list
            if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
                export AGE_RECIPIENTS="$AGE_RECIPIENTS,$recipient"
            else
                export AGE_RECIPIENTS="$recipient"
            fi
            
            # Update config file
            __print_padlock_config "locker/.padlock" "$(basename "$PWD")"
            
            okay "‚úì Added recipient: ${recipient:0:20}..."
            info "Re-encrypt with: padlock lock"
            ;;
        *)
            error "Unknown key action: $action"
            info "Available actions:"
            info "  --set-global <key>     Set global master key"
            info "  --show-global          Display global public key"
            info "  --generate-global      Generate new global key"
            info "  --add-recipient <key>  Add recipient to current repo"
            return 1
            ;;
    esac
}

# Safe declamp operation - remove padlock infrastructure while preserving data
do_declamp() {
    local repo_path="${1:-.}"
    local force="${2:-}"
    
    repo_path="$(realpath "$repo_path")"
    
    # Validate target
    if ! is_git_repo "$repo_path"; then
        fatal "Target is not a git repository: $repo_path"
    fi
    
    REPO_ROOT="$(_get_repo_root "$repo_path")"
    
    # Check if padlock is deployed
    if ! is_deployed "$REPO_ROOT"; then
        error "Padlock not deployed in this repository"
        info "Nothing to declamp"
        return 1
    fi
    
    lock "üîì Safely declamping padlock from repository..."
    
    # Ensure repository is unlocked first
    if [[ -f "$REPO_ROOT/locker.age" ]] || [[ -d "$REPO_ROOT/.chest" ]]; then
        if [[ "$force" != "--force" ]]; then
            error "Repository is locked. Unlock first or use --force"
            info "To unlock: padlock unlock"
            info "Or force: padlock declamp --force"
            return 1
        fi
        
        # Force unlock before declamp
        warn "Force-unlocking locked repository..."
        if [[ -f "$REPO_ROOT/locker.age" ]]; then
            info "Unlocking standard locker..."
            if ! (cd "$REPO_ROOT" && "$REPO_ROOT/bin/padlock" unlock); then
                fatal "Failed to unlock repository for declamp"
            fi
        elif [[ -d "$REPO_ROOT/.chest" ]]; then
            info "Unlocking chest mode..."
            if ! (cd "$REPO_ROOT" && "$REPO_ROOT/bin/padlock" ignite --unlock); then
                fatal "Failed to unlock chest for declamp"
            fi
        fi
    fi
    
    # Show what will be preserved
    if [[ -d "$REPO_ROOT/locker" ]]; then
        local file_count
        file_count=$(find "$REPO_ROOT/locker" -type f | wc -l)
        info "üìÅ Preserving $file_count files from locker/ (will remain as plaintext)"
    else
        warn "No locker directory found - nothing to preserve"
    fi
    
    # Show what will be removed
    local items_to_remove=()
    [[ -d "$REPO_ROOT/bin" ]] && items_to_remove+=("bin/")
    [[ -d "$REPO_ROOT/.githooks" ]] && items_to_remove+=(".githooks/")
    [[ -f "$REPO_ROOT/locker.age" ]] && items_to_remove+=("locker.age")
    [[ -f "$REPO_ROOT/.locked" ]] && items_to_remove+=(".locked")
    [[ -d "$REPO_ROOT/.chest" ]] && items_to_remove+=(".chest/")
    [[ -f "$REPO_ROOT/SECURITY.md" ]] && items_to_remove+=("SECURITY.md")
    
    if [[ ${#items_to_remove[@]} -gt 0 ]]; then
        info "üóëÔ∏è  Will remove: ${items_to_remove[*]}"
    fi
    
    # Confirm destructive operation
    if [[ "$force" != "--force" ]]; then
        echo
        warn "‚ö†Ô∏è  This will permanently remove padlock infrastructure"
        read -p "Continue? (y/N): " -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            info "Declamp cancelled"
            return 0
        fi
    fi
    
    # Remove padlock infrastructure
    local removed_items=()
    
    # Remove bin directory
    if [[ -d "$REPO_ROOT/bin" ]]; then
        rm -rf "$REPO_ROOT/bin"
        removed_items+=("bin/")
    fi
    
    # Remove git hooks
    if [[ -d "$REPO_ROOT/.githooks" ]]; then
        rm -rf "$REPO_ROOT/.githooks"
        removed_items+=(".githooks/")
    fi
    
    # Remove encrypted artifacts
    if [[ -f "$REPO_ROOT/locker.age" ]]; then
        rm -f "$REPO_ROOT/locker.age"
        removed_items+=("locker.age")
    fi
    
    if [[ -f "$REPO_ROOT/.locked" ]]; then
        rm -f "$REPO_ROOT/.locked"
        removed_items+=(".locked")
    fi
    
    if [[ -d "$REPO_ROOT/.chest" ]]; then
        rm -rf "$REPO_ROOT/.chest"
        removed_items+=(".chest/")
    fi
    
    # Remove other padlock files
    rm -f "$REPO_ROOT/.locker_checksum"
    rm -f "$REPO_ROOT/.overdrive"
    rm -f "$REPO_ROOT/super_chest.age"
    
    # Clean up .gitattributes (remove padlock lines)
    if [[ -f "$REPO_ROOT/.gitattributes" ]]; then
        local temp_attrs
        temp_attrs=$(mktemp)
        grep -v "locker.age\|filter=locker-crypt\|bin/\*\|.githooks/\*" "$REPO_ROOT/.gitattributes" > "$temp_attrs" || true
        mv "$temp_attrs" "$REPO_ROOT/.gitattributes"
        
        # Remove file if empty (except comments and whitespace)
        if ! grep -q "^[^#[:space:]]" "$REPO_ROOT/.gitattributes" 2>/dev/null; then
            rm -f "$REPO_ROOT/.gitattributes"
            removed_items+=(".gitattributes")
        fi
    fi
    
    # Clean up .gitignore (remove padlock lines)
    if [[ -f "$REPO_ROOT/.gitignore" ]]; then
        local temp_ignore
        temp_ignore=$(mktemp)
        grep -v "^locker/$\|^# Padlock" "$REPO_ROOT/.gitignore" > "$temp_ignore" || true
        mv "$temp_ignore" "$REPO_ROOT/.gitignore"
    fi
    
    # Remove git configuration
    (cd "$REPO_ROOT" && {
        git config --unset filter.locker-crypt.clean 2>/dev/null || true
        git config --unset filter.locker-crypt.smudge 2>/dev/null || true
        git config --unset filter.locker-crypt.required 2>/dev/null || true
        git config --unset core.hooksPath 2>/dev/null || true
    })
    
    # Remove from global manifest
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        grep -v -F "$REPO_ROOT" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        trace "Removed from global manifest"
    fi
    
    # Remove template SECURITY.md if it's the padlock one
    if [[ -f "$REPO_ROOT/SECURITY.md" ]] && grep -q "Padlock" "$REPO_ROOT/SECURITY.md" 2>/dev/null; then
        rm -f "$REPO_ROOT/SECURITY.md"
        removed_items+=("SECURITY.md")
    fi
    
    # Success message
    okay "‚úì Padlock safely removed from repository"
    
    if [[ -d "$REPO_ROOT/locker" ]]; then
        local preserved_count
        preserved_count=$(find "$REPO_ROOT/locker" -type f | wc -l)
        okay "‚úÖ Preserved $preserved_count files in locker/ (now unencrypted)"
        warn "‚ö†Ô∏è  locker/ is now unencrypted plaintext"
        info "üí° Add 'locker/' to .gitignore before committing"
    fi
    
    if [[ ${#removed_items[@]} -gt 0 ]]; then
        info "üóëÔ∏è  Removed: ${removed_items[*]}"
    fi
    
    info "üìã Repository restored to standard git repo"
}

# Revocation operations - remove access to encrypted content
do_revoke() {
    local target="$1"
    local force="${2:-}"
    
    case "$target" in
        --local)
            _revoke_local_access "$force"
            ;;
        -K|--ignition)
            _revoke_ignition_access "$force"
            ;;
        *)
            error "Unknown revocation target: $target"
            info "Available targets:"
            info "  --local       Revoke local access (WARNING: makes content unrecoverable)"
            info "  --ignition    Revoke ignition key access"
            return 1
            ;;
    esac
}

# Revoke local access - WARNING: This makes content permanently unrecoverable
_revoke_local_access() {
    local force="$1"
    
    REPO_ROOT="$(_get_repo_root .)"
    
    error "‚ö†Ô∏è  DESTRUCTIVE OPERATION: Local access revocation"
    warn "This will make ALL encrypted content permanently unrecoverable!"
    warn "Even with master keys, the content will be lost."
    echo
    info "This operation will:"
    info "  ‚Ä¢ Remove local repository key"
    info "  ‚Ä¢ Remove master key references"
    info "  ‚Ä¢ Leave locker.age encrypted but unrecoverable"
    echo
    
    if [[ "$force" != "--force" ]]; then
        error "This operation requires --force flag to confirm"
        info "Usage: padlock revoke --local --force"
        return 1
    fi
    
    # Additional confirmation
    echo
    warn "‚ö†Ô∏è  FINAL WARNING: This will permanently destroy access to encrypted data"
    read -p "Type 'DESTROY' to confirm: " -r confirm
    if [[ "$confirm" != "DESTROY" ]]; then
        info "Revocation cancelled"
        return 0
    fi
    
    local revoked_items=()
    
    # Remove local repository key
    local repo_key="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
    if [[ -f "$repo_key" ]]; then
        rm -f "$repo_key"
        revoked_items+=("local repository key")
    fi
    
    # Remove master key reference from any config
    if [[ -f "$REPO_ROOT/locker/.padlock" ]]; then
        # If unlocked, remove master key from recipients
        source "$REPO_ROOT/locker/.padlock"
        if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
            # Remove master key recipient
            local master_public
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                master_public=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null || true)
                if [[ -n "$master_public" ]]; then
                    # Remove master key from recipients list
                    AGE_RECIPIENTS=$(echo "$AGE_RECIPIENTS" | sed "s/,$master_public//g" | sed "s/$master_public,//g" | sed "s/$master_public//g")
                    export AGE_RECIPIENTS
                    __print_padlock_config "$REPO_ROOT/locker/.padlock" "$(basename "$REPO_ROOT")"
                    revoked_items+=("master key access")
                fi
            fi
        fi
    fi
    
    # Remove from manifest
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        grep -v -F "$REPO_ROOT" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        revoked_items+=("manifest entry")
    fi
    
    # Create revocation marker
    cat > "$REPO_ROOT/.revoked" << EOF
# Padlock Access Revoked
# Generated: $(date)
# Repository: $(basename "$REPO_ROOT")

This repository's encryption keys have been revoked.
The encrypted content in locker.age is permanently unrecoverable.

Revoked access types:
$(printf "  ‚Ä¢ %s\n" "${revoked_items[@]}")

If this was done in error, restore from backup immediately.
EOF
    
    error "üîí Local access permanently revoked"
    if [[ ${#revoked_items[@]} -gt 0 ]]; then
        info "Revoked: ${revoked_items[*]}"
    fi
    warn "‚ö†Ô∏è  Encrypted content is now permanently unrecoverable"
    info "üíÄ Created .revoked file as marker"
}

# Revoke ignition access - removes ignition key system
_revoke_ignition_access() {
    local force="$1"
    
    REPO_ROOT="$(_get_repo_root .)"
    
    if [[ ! -d "$REPO_ROOT/.chest" ]]; then
        error "Repository is not using ignition system"
        info "Nothing to revoke"
        return 1
    fi
    
    lock "üî• Revoking ignition key access..."
    
    local revoked_items=()
    
    # Remove ignition key files
    if [[ -f "$REPO_ROOT/.chest/ignition.age" ]]; then
        rm -f "$REPO_ROOT/.chest/ignition.age"
        revoked_items+=("encrypted ignition key")
    fi
    
    # Remove any temporary ignition keys
    rm -f "$REPO_ROOT/.ignition.key"
    
    # If chest is unlocked, we need to transition to standard mode
    if [[ -d "$REPO_ROOT/locker" ]] && [[ -f "$REPO_ROOT/locker/.padlock" ]]; then
        info "Converting from ignition to standard mode..."
        
        # Generate new repository key
        local new_repo_key="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        age-keygen -o "$new_repo_key" >/dev/null
        chmod 600 "$new_repo_key"
        
        # Get new public key
        local new_public
        new_public=$(age-keygen -y "$new_repo_key")
        
        # Update configuration to standard mode with master key backup
        _ensure_master_key
        local master_public
        master_public=$(age-keygen -y "$PADLOCK_GLOBAL_KEY")
        
        export AGE_RECIPIENTS="$new_public,$master_public"
        export AGE_KEY_FILE="$new_repo_key"
        export AGE_PASSPHRASE=""
        
        __print_padlock_config "$REPO_ROOT/locker/.padlock" "$(basename "$REPO_ROOT")"
        
        info "üîë Generated new repository key for standard mode"
        revoked_items+=("ignition system")
        revoked_items+=("converted to standard mode")
    fi
    
    # Remove chest directory if empty
    if [[ -d "$REPO_ROOT/.chest" ]] && [[ -z "$(ls -A "$REPO_ROOT/.chest" 2>/dev/null)" ]]; then
        rm -rf "$REPO_ROOT/.chest"
        revoked_items+=("chest directory")
    fi
    
    # Update manifest type
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        # Change type from ignition to standard
        sed "s/|$REPO_ROOT|ignition|/|$REPO_ROOT|standard|/g" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        trace "Updated manifest type to standard"
    fi
    
    okay "‚úì Ignition access revoked"
    if [[ ${#revoked_items[@]} -gt 0 ]]; then
        info "Changes: ${revoked_items[*]}"
    fi
    
    if [[ -d "$REPO_ROOT/locker" ]]; then
        info "üìù Repository is now in standard mode"
        info "üîê Re-encrypt with: padlock lock"
    else
        info "üîí Repository remains locked in standard mode"
        info "üîì Unlock with: padlock unlock"
    fi
}

# === 07_core.sh ===
dispatch() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        clamp)
            do_clamp "$@"
            ;;
        setup)
            do_setup "$@"
            ;;
        lock)
            do_lock "$@"
            ;;
        unlock)
            do_unlock "$@"
            ;;
        status)
            do_status "$@"
            ;;
        key)
            do_key "$@"
            ;;
        install)
            do_install "$@"
            ;;
        uninstall)
            do_uninstall "$@"
            ;;
        master-unlock)
            do_master_unlock "$@"
            ;;
        ignite)
            do_ignite "$@"
            ;;
        rotate)
            do_rotate "$@"
            ;;
        list)
            do_list "$@"
            ;;
        clean-manifest)
            do_clean_manifest "$@"
            ;;
        declamp)
            do_declamp "$@"
            ;;
        revoke)
            do_revoke "$@"
            ;;

        export)
            do_export "$@"
            ;;
        import)
            do_import "$@"
            ;;
        snapshot)
            do_snapshot "$@"
            ;;
        rewind)
            do_rewind "$@"
            ;;

        overdrive)
            do_overdrive "$@"
            ;;

        help|--help|-h)
            usage
            ;;
        version|--version|-v)
            printf "padlock %s\n" "$PADLOCK_VERSION"
            ;;
        dev_test)
            if is_dev; then
                dev_test "$@"
            else
                fatal "Dev command requires -D flag"
            fi
            ;;
        *)
            error "Unknown command: $cmd"
            info "Run 'padlock help' for available commands"
            return 1
            ;;
    esac
}

usage() {
    cat << 'USAGE_EOF'
Padlock - Git Repository Security Orchestrator

USAGE:
    padlock <command> [options]

COMMANDS:
    clamp <path>     Deploy padlock to a git repository
      --global-key   Use or create global key
      --generate     Generate new repo-specific key
      --key <key>    Use explicit key
      -K, --ignition [key]  Enable ignition mode for AI collaboration

    setup           Setup encryption (first time in repo)
    lock            Encrypt locker/ ‚Üí locker.age
    unlock          Decrypt locker.age ‚Üí locker/
    status          Show current lock/unlock state with next steps

    master-unlock   Emergency unlock using global master key
    ignite          Ignition key operations
      --unlock       Unlock chest with ignition key
      --lock         Lock locker into chest
      --status       Show chest status
    rotate          Rotate keys
      --ignition     Rotate the ignition key passphrase

    key             Manage encryption keys
      --set-global <key>      Store global key
      --show-global           Display global key
      --generate-global       Create new global key

    install         Install padlock to your system for global access
    uninstall       Remove padlock from your system

    Manifest Management:
    list [--all|--ignition|--namespace <ns>]
                    List tracked repositories
    clean-manifest  Prune stale entries from the manifest

    Backup and Restore:
    export [file]   Export entire padlock environment to an encrypted file
    import <file>   Import an environment from an export file
    snapshot [name] Create a named backup snapshot of the current environment
    rewind <name>   Restore the environment from a named snapshot


    Advanced:
    overdrive       Engage overdrive mode (encrypts entire repo)

    help            Show this help
    version         Show version

WORKFLOW:
    # Deploy to repository with ignition mode
    padlock clamp /path/to/repo -K

    # Work with secrets locally
    cd /path/to/repo
    echo "secret content" > locker/docs_sec/private.md

    # Commit (auto-encrypts)
    git add . && git commit -m "Add secrets"

    # Share ignition key for AI collaboration
    export PADLOCK_IGNITION_PASS="flame-rocket-boost-spark"
    source .locked

    # Emergency unlock if keys are lost
    padlock master-unlock

EXAMPLES:
    # Standard deployment
    padlock clamp . --generate

    # AI collaboration setup
    padlock clamp . -K "my-custom-ignition-key"

    # Emergency recovery
    padlock master-unlock

    # Check repository state
    padlock status

USAGE_EOF
}

options() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug)
                opt_debug=1
                trace "Debug mode enabled"
                shift
                ;;
            -t|--trace)
                opt_trace=1
                opt_debug=1  # Trace implies debug
                trace "Trace mode enabled"
                shift
                ;;
            -q|--quiet)
                opt_quiet=1
                shift
                ;;
            -f|--force)
                opt_force=1
                trace "Force mode enabled"
                shift
                ;;
            -y|--yes)
                opt_yes=1
                trace "Auto-yes mode enabled"
                shift
                ;;
            -D|--dev)
                opt_dev=1
                opt_debug=1
                opt_trace=1
                trace "Developer mode enabled"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                printf "padlock %s\n" "$PADLOCK_VERSION"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                error "Unknown option: $1"
                info "Use -h for help"
                exit 1
                ;;
            *)
                # Not an option, break to handle as command
                break
                ;;
        esac
    done

    # Return remaining arguments
    return 0
}

dev_test() {
    if ! is_dev; then
        fatal "dev_test requires developer mode (-D)"
    fi

    lock "üß™ Running developer tests..."

    # Test crypto functions
    info "Testing crypto stream functions..."
    local test_data="test encryption data"

    # Set up test crypto
    AGE_PASSPHRASE="test-passphrase-123"

    # Test encrypt/decrypt cycle
    local encrypted decrypted
    encrypted=$(echo "$test_data" | __encrypt_stream)
    decrypted=$(echo "$encrypted" | __decrypt_stream)

    if [[ "$decrypted" == "$test_data" ]]; then
        okay "Crypto stream test passed"
    else
        error "Crypto stream test failed"
        trace "Expected: $test_data"
        trace "Got: $decrypted"
    fi

    # Test guard functions
    info "Testing guard functions..."

    if is_dev; then
        okay "is_dev() test passed"
    else
        error "is_dev() test failed"
    fi

    # Test repo detection
    info "Testing repo detection..."

    if is_git_repo "."; then
        okay "Git repo detection passed"
    else
        warn "Not in a git repo (expected for isolated testing)"
    fi

    # Test XDG paths
    info "Testing XDG paths..."
    trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    trace "PADLOCK_ETC: $PADLOCK_ETC"
    trace "PADLOCK_KEYS: $PADLOCK_KEYS"

    okay "Developer tests completed"
}

# === 08_main.sh ===
################################################################################
# Main Function - Primary Entrypoint
################################################################################

main() {
    local ret=0
    
    # Early environment checks
    if [[ "${BASH_VERSION%%.*}" -lt 4 ]]; then
        fatal "Bash 4.0+ required (found: $BASH_VERSION)"
    fi
    
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        usage
        return 0
    fi
    
    # Parse options first (modifies opt_* variables)
    options "$@"
    
    # Skip processed options to get to command
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug|-t|--trace|-q|--quiet|-f|--force|-y|--yes|-D|--dev)
                shift
                ;;
            -h|--help|-v|--version)
                # These are handled in options() and exit
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                shift  # Skip unknown options (already handled in options())
                ;;
            *)
                # Found command
                break
                ;;
        esac
    done
    
    # Show startup info in dev mode
    if is_dev; then
        trace "Padlock v$PADLOCK_VERSION starting..."
        trace "Script: $SCRIPT_PATH"
        trace "PID: $$"
        trace "Args: $*"
        trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    fi
    
    # Dispatch to command handlers
    if [[ $# -gt 0 ]]; then
        dispatch "$@" || ret=$?
    else
        # No command provided after parsing options
        usage
    fi
    
    # Clean exit
    if is_dev; then
        trace "Padlock exiting with status: $ret"
    fi
    
    return $ret
}
# === 09_footer.sh ===
################################################################################
# Footer - Script Invocation
################################################################################

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
